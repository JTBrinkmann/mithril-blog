<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title>Learn Mithril</title>
		<description>A Javascript framework for building brilliant applications</description>
		<link>http://lhorie.github.io/mithril-blog/</link>
		<item>
			<title>A spreadsheet in 60 lines of javascript</title>
			<link>http://lhorie.github.io/mithril-blog/a-spreadsheet-in-60-lines-of-javascript.html</link>
			<description><![CDATA[
<h2 id="a-spreadsheet-in-60-lines-of-javascript">A spreadsheet in 60 lines of Javascript</h2>
<p>Apps with terse code have a special place in my heart. Note that I said <em>terse</em>, not <em>clever</em>. Cleverness is a tendency to sacrifice code clarity and readability in order to push code size to be smaller (think code golfing). Being terse, on the other hand, is the practice of seeking simplicity in order to make code easier to understand. It implies looking for elegant solutions and avoiding over-engineering.</p>
<p>One such app that looks particularly impressive is this <a href="http://jsfiddle.net/ondras/hYfN3/">spreadsheet</a>, written in a mere 30 lines of vanilla javascript.</p>
<p>I decided to write a version of it using <a href="http://lhorie.github.io/mithril">Mithril</a>. It may seem silly to require a framework (even if it&#39;s a really small one) to do something that has been proven to be doable without one, but the purpose of this exercise is precisely to get an idea of how much boilerplate would be required in order to implement the app using the Mithril framework.</p>
<p>This is an important consideration. Frameworks usually require boilerplate code in order to work, and frameworks like Angular can get notoriously verbose. Verbosity can add various costs to development: extra typing required, steep learning curves, more mental baggage to carry when reading code.</p>
<pre><code class="lang-javascript">//A simple, production-quality AngularJS factory
(function() {
    function something($http) {
        //code here
    }

    something.$injector = [&quot;$http&quot;]

    angular.module(&quot;spreadsheet&quot;).factory(something)
})()
</code></pre>
<p>Mithril positions itself as a minimalist framework. Minimalism can be a slippery slope. It&#39;s easy to make a &quot;minimalist&quot; framework that defers all the hard work to the application developer, but the real goal of minimalism in the context of frameworks is to enable developers to simplify their own codebases <em>in addition</em> to being a simple framework. So let&#39;s see how Mithril fares.</p>
<hr>
<h3 id="the-model-layer">The model layer</h3>
<p>Here&#39;s a <a href="">tit-for-tat port of the spreadsheet code to Mithril</a>.</p>
<p>The <code>data</code> variable is the in-memory data store. It reads from <code>localStorage</code> on page load and it&#39;s used throughout the code to store the current state of the spreadsheet data. It&#39;s a map of values, whose keys are expect to be named after their cells (e.g. <code>data[&quot;a1&quot;]</code>, <code>data[&quot;b3&quot;]</code>, etc)</p>
<pre><code class="lang-javascript">var data = JSON.parse(localStorage[&quot;spreadsheet&quot;] || &quot;{}&quot;)
</code></pre>
<p>The <code>update</code> function computes an expression if it&#39;s a string that starts with <code>&quot;=&quot;</code>. Then it saves the computed value to both in the in-memory map and <code>localStorage</code>. Here, again, cells are named by combining the letters for the x axis and the numbers from the y axis (e.g. <code>&quot;a1&quot;</code>)</p>
<pre><code class="lang-javascript">function update(cell, value) {
    if (value != null &amp;&amp; value[0] == &quot;=&quot;) {
        try { with (data) data[cell] = eval(value.substring(1)) } catch (e) {}
    }
    else data[cell] = isNaN(+value) ? value : +value
    localStorage[&quot;spreadsheet&quot;] = JSON.stringify(data)
}
</code></pre>
<h3 id="the-view-layer">The view layer</h3>
<p>The <code>grid</code> function creates a table and accepts an arbitrary Mithril template as an argument, which is cloned for every cell in the table.</p>
<pre><code class="lang-javascript">function grid(withCell) {
    for (var rows = [], i = 0; i &lt; 27; i++) {
        for (var cols = [], j = 0; j &lt; 17; j++) {
            var letter = String.fromCharCode(&quot;a&quot;.charCodeAt(0) + j - 1)
            cols.push(m(&quot;td&quot;, i &amp;&amp; j ? withCell(letter + i) : i || letter))
        }
        rows.push(m(&quot;tr&quot;, cols))
    }
    return m(&quot;table&quot;, rows)
}
</code></pre>
<p>The <code>view</code> function is the main template. It creates a grid of text inputs, each of which has bindings to synchronize their values to a slot in the <code>data</code> map.</p>
<p>The <code>cellName</code> argument is the name of the corresponding cell. The name of the very first cell is &quot;a1&quot;, the one beside that is &quot;a2&quot;, and so on.</p>
<pre><code class="lang-javascript">function view() {
    return grid(function(cellName) {
        return m(&quot;input&quot;, {
            onchange: m.withAttr(&quot;value&quot;, update.bind(this, cellName)),
            value: data[cellName] || &quot;&quot;
        })
    })
}
</code></pre>
<p>Finally, the last line tells Mithril to run the application:</p>
<pre><code class="lang-javascript">m.module(document.body, {controller: function() {}, view: view})
</code></pre>
<p>You may have noticed the empty controller. There&#39;s only a single writing method in the model (<code>update</code>), and we&#39;re calling it directly from the view to cut down on boilerplate.</p>
<p>As you can see, the code isn&#39;t that complicated: there&#39;s a map of values whose keys are the names of the cells. Whenever an input changes, its respective value is computed (if it&#39;s an <code>eval</code>able expression), and then saved to its respective slot in the <code>data</code> map (and also to <code>localStorage</code>). Then Mithril redraws and puts the UI back in sync with the data.</p>
<p>And this port only takes 28 lines of code, just like the original. Not bad.</p>
<hr>
<h3 id="extending-the-application">Extending the application</h3>
<p>We saw that porting the vanilla app to Mithril yields very little boilerplate, while keeping code quite readable. But the real test for terseness is whether we can build more functionality on top of it: <em>clever</em> code is full of obscurities and it&#39;s hard to understand and modify, but <em>elegant</em> code should be easy to refactor.</p>
<p>Conveniently, we can put our code to the test, because this spreadsheet app can use some improvements. As you might already know, the whole point of a spreadsheet is that they are supposed to be <em>reactive</em>. If the value of <code>a3</code> is <code>&quot;=a1+a2&quot;</code>, then changing the value of <code>a1</code> should also change <code>a3</code>.</p>
<p>Currently our app simply overwrites the expression so once it&#39;s computed, we lose its formula.</p>
<p>Here&#39;s a <a href="">rewrite that fixes that</a>.</p>
<p>The first major change is that our <code>update</code> function is now broken out into three parts: </p>
<ul>
<li>the <code>update</code> function takes care of saving to the in-memory data store and to localStorage as before (but it no longer performs the evaluation of expressions)</li>
<li>the <code>compute</code> function takes care of the expression evaluation logic</li>
<li>and finally, the <code>computable</code> function is a <strong>value object factory</strong>. If the input to this function is a number or a string, it simply returns that value, but if the input is an <code>eval</code>able expression (i.e. a string beginning w/ <code>=</code> and followed by a javascript expression), it returns a String object with a custom <code>valueOf</code> method that computes its <code>eval</code>able expression when called.</li>
</ul>
<pre><code>function computable(value) {
    var output = new String(value)
    output.valueOf = compute.bind(this, value)
    return isNaN(+value) ? output : +value
}
function compute(value) {
    if (value != null &amp;&amp; value[0] == &quot;=&quot;) {
        try { with (data) return eval(value.substring(1)) } catch (e) {}
    }
    else return value
}
function update(cell, value) {
    data[cell] = computable(value)
    localStorage[&quot;spreadsheet&quot;] = JSON.stringify(data)
}
</code></pre><p>Breaking out <code>compute</code> from <code>update</code> is a fairly standard type of refactorization: we&#39;re simply decoupling code for better separation of concerns and better reusability.</p>
<p>The creation of the <code>computable</code> factory is the key refactorization: a computable enables us to store expressions that can evaluate their values on demand. This function is used by the <code>update</code> function to store computable values in our in-memory <code>data</code> store, and it&#39;s also used at the very beginning of the script to turn the deserialized <code>localStorage</code> data into computable value objects.</p>
<pre><code class="lang-javascript">var data = JSON.parse(localStorage[&quot;spreadsheet&quot;] || &quot;{}&quot;)
for (var cell in data) data[cell] = computable(data[cell])
</code></pre>
<p>A computable value object is an immutable object that behaves mostly like a javascript primitive number or string, with one exception: when we attempt to use a computable entity in a mathematical expression, it implicitly calls the custom <code>valueOf</code> method and uses the evaluated expression instead of using the string value. This allows expressions like <code>a1+a2</code> to perform mathematical computations seamlessly regardless of whether <code>a1</code> and <code>a2</code> are numbers or computables. And since computables can evaluate to expressions that reference other computables, they can recursively cascade a data change through a complex web of computable expressions.</p>
<p>Here are some tests to demonstrate the expected behavior of the computable value object:</p>
<pre><code class="lang-javascript">computable(1) == 1 // true
computable(&quot;hello&quot;) == &quot;hello&quot; // true
computable(&quot;=1+1&quot;).toString() == &quot;=1+1&quot; // true
computable(&quot;=1+1&quot;).valueOf() == 2 // true

data.a1 = 1
computable(&quot;=a1+2&quot;) + 3 == 6 //true

data.a1 = 1
data.a2 = computable(&quot;=a1+2&quot;)
computable(&quot;=a2+3&quot;) + 4 == 10 //true
</code></pre>
<p>In the last two tests you can see how tightly integrated to the language <code>valueOf</code> is. The <code>toString</code> and <code>valueOf</code> methods are implicitly called by Javascript whenever type casting is implied. Computable expressions take advantage of this language feature to implement reactivity.</p>
<hr>
<p>The second major change is that now there&#39;s a formula input at the top. This UI addition lets us see and edit the un-evaluated expression for any given cell.</p>
<p>You can see how the bindings for this input work by looking at the <code>view</code> function:</p>
<pre><code class="lang-javascript">function view() {
    return [
        m(&quot;input.formula&quot;, {
            onchange: m.withAttr(&quot;value&quot;, update.bind(this, cell())),
            value: data[cell()] || &quot;&quot;
        }),
        grid(function(cellName) {
            var value = compute(data[cellName]) || &quot;&quot;
            return m(&quot;input&quot;, {
                onkeypress: move,
                onfocus: cell.bind(this, cellName),
                onchange: m.withAttr(&quot;value&quot;, update.bind(this, cellName)),
                value: value,
                style: {textAlign: isNaN(value) || value === &quot;&quot; ? &quot;left&quot; : &quot;right&quot;}
            })
        })
    ]
}
</code></pre>
<p>The <code>cell</code> variable is simply a view-model getter-setter that holds the name of a cell.</p>
<p>The <code>&quot;input.formula&quot;</code> element has a binding that references the <code>cell</code> getter-setter: when this input is changed, we update the data for the cell referenced by <code>cell()</code>. The value for this input is simply the string value of the <code>data</code> slot referenced by <code>cell()</code>.</p>
<p>In addition, each input in the grid now has a <code>onfocus</code> handler that sets the value of <code>cell</code> to their respective cell names. In short, focusing on a cell displays the uncomputed value for that cell.</p>
<hr>
<p>Finally, one handy UI improvement was added: the app is now keyboard-aware. Pressing the arrows on the keyboard now moves focus around the grid. This happens thanks to the <code>onkeypress</code> event handler <code>move</code>.</p>
<pre><code class="lang-javascript">function move(e) {
    var td = e.target.parentNode, tr = td.parentNode, table = tr.parentNode
    if (e.keyCode == 37) return highlight(tr.childNodes[Math.max(1, td.cellIndex - 1)].firstChild)
    else if (e.keyCode == 38) return highlight(table.childNodes[Math.max(1, tr.rowIndex - 1)].childNodes[td.cellIndex].firstChild)
    else if (e.keyCode == 39) return highlight(tr.childNodes[Math.min(tr.childNodes.length - 1, td.cellIndex + 1)].firstChild)
    else if (e.keyCode == 40) return highlight(table.childNodes[Math.min(table.childNodes.length - 1, tr.rowIndex + 1)].childNodes[td.cellIndex].firstChild)
    else m.redraw.strategy(&quot;none&quot;)
}
function highlight(cell) {
    cell.focus()
    cell.selectionEnd = cell.value.length
    return false
}
</code></pre>
<p>There&#39;s also a one-liner in <code>view</code> that takes care of text alignment of numbers vs text, but other than that, that&#39;s pretty much it. These few UI improvements add 16 lines to the code (more than half of the original size!), but I&#39;d argue that being able to navigate a spreadsheet with the keyboard and quickly be able to tell apart text from numbers are important features to have - if you disagree, you can reduce the code size by 16 lines and still have a reactive spreadsheet :)</p>
<hr>
<p>Once you understand the <code>computable</code> value object, the rest of the application is fairly straightforward: it boils down to the basic principle of data flowing from the model to the view, and then using event handlers to push changes back to the model.</p>
<p>We already covered in other articles some reasons as to what makes this Mithril app clean (despite it having non-trivial functionality like focus-aware reactivity), but it&#39;s worth mentioning them again: </p>
<ul>
<li>Mithril&#39;s &quot;call-me-when-you-need&quot; approach to tooling and the well-defined flow of data makes it easy to spend time thinking about the problem domain, rather than wasting time on framework-specific concepts.</li>
<li>Explicit data bindings (as opposed to cookie-cutter binding tools like <code>ng-model</code>) allow a greater degree of flexibility when connecting form elements to model data slots, which paradoxically results in less complexity.</li>
<li>The ability to idiomatically have procedural code live in functions in the view layer lets us express DOM actions without a lot of boilerplate integration code</li>
<li>Idiomatic Mithril code takes the concept of design patterns to heart: we implement <em>patterns</em> of code in their simplest form, rather than creating bulky classes named after patterns.</li>
</ul>
<p>Another thing that is worth noting (especially for those who are averse to Mithril&#39;s templating syntax), is that even though this app literally fills the page with DOM elements, there&#39;s very little &quot;markup&quot; code. This illustrates well the fact that, in non-trivial applications, logic often dominates in terms of code volume. A lot of boilerplate in other frameworks come from shuffling logic around in order to keep HTML &quot;clean&quot; in a way that is reminicent of <a href="http://en.wikipedia.org/wiki/Zero-sum_game">zero sum games</a> (i.e. get clarity over here at the expense of added complexity over there). We&#39;ve learned long ago to forego normalization purity in databases in favor of a pragmatic middle ground, and I think this app is an example that shows that pragmatism is a good design driver in frontend as well.</p>

			]]></description>
		</item>
		<item>
			<title>What is a view-model</title>
			<link>http://lhorie.github.io/mithril-blog/what-is-a-view-model.html</link>
			<description><![CDATA[
<h2 id="what-is-a-view-model">What is a View Model</h2>
<p><em>This article was adapted from an essay in the mailing list</em></p>
<p>Last week we saw how we can animate things with Velocity.js. A related topic that came up on the Mithril bug tracker (and that keeps coming up every once in a while) is the topic of <em>application</em> state (as opposed to <em>data</em> state). Today we&#39;ll explore that topic:</p>
<p>Let&#39;s imagine we have a button, and that when we click on that button, a panel shows up. When we click on the button again, the panel disappears. In jQuery, we can code this in an action-centered way: &quot;on click, show&quot;. Mithril, however, (and for that matter, most MVC frameworks) encourages us to be data-centered: &quot;if this flag is set, show&quot;. This means that when we are debugging, instead of having to use PhantomJS to emulate a user clicking through our app to get to a specific state in our application, we can always render the exact UI state that we want if we have our data setup in just the right way. And since data is easy to manipulate via plain javascript, the entire testing workflow is also a lot easier as a result.</p>
<p>But a &quot;this panel is open&quot; flag is not really a &quot;model&quot; value in the traditional sense. It doesn&#39;t map to &quot;Users&quot; or &quot;Projects&quot;, or to anything else that we might want to store in a database. It&#39;s merely data <em>about</em> the UI. This type of data is also known as <em>application state</em>.</p>
<p>Many people get confused when they need to decide where this application state should go. Should it go in the controller? Should it be hidden in the view layer behind a helper function?</p>
<p>The answer is that it is <strong>state</strong> after all, so it should be in the model layer.</p>
<p>The rationale for this goes back to the definition of MVC: </p>
<ul>
<li>the Model layer is responsible for application data, business rules and logic.</li>
<li>the View is responsible for displaying data</li>
<li>the Controller is a mechanism that translates user input into commands for the model layer</li>
</ul>
<hr>
<h3 id="a-little-bit-of-history">A little bit of history</h3>
<p>In classic MVC (the original Smalltalk one), the Model layer notifies the view of changes to data; the view can send messages to the controller to tell the app to do things; the controller then manipulates the model, which then notifies the view, ad infinitum. The controller may also modify the view without assistance from the Model layer (for example to show a loading icon.) In this original implementation, all layers could contain code: the view could subscribe to model events via the observer pattern, and likewise, the model could trigger events via the same mechanism.</p>
<p>Since then, a lot of twists have been made: we adapted the pattern from the realm of desktop apps to the realm of server-side architectures, and from there to thick client-side architectures. Somewhere along the lines, we started to conflate the View layer with HTML, the Model layer with database tables, and reached the conclusion that anything that is neither HTML nor SQL related must be part of the Controller layer.</p>
<p>In server-side architectures, application state largely became conflated with URLs (so much so, that POST-only URLs are still considered bad practice, since they make it hard to reach certain states). Client-side MVC became prominent precisely because URLs were not enough to express all possible states in heavily AJAX-driven applications. So as complexity grew, we started to see a sort of limbo with application state that didn&#39;t fit into a URL, and that didn&#39;t really fit anywhere else either (given the cookie-cutter molds that frameworks provided us).</p>
<p>One of the things I&#39;m trying to do with Mithril is encourage people to go back to the basics and realize that a lot of the assumptions and cloudiness surrounding MVC is actually wrong: the view layer isn&#39;t HTML-only, the model layer isn&#39;t supposed to be solely about ORM classes, controllers aren&#39;t supposed to be a pool where we dump things that we don&#39;t know how to fit into the rest of the framework.</p>
<p>Going back to the topic of application state: state is just data. <em>Meta</em> data, but still data. Here&#39;s an example to illustrate that point: sortable tables. You have a table full of data, you click on a header, it sorts by that header. What if you want to permalink this configuration? Often, we modify the app so that the sorting options are part of the URL. But what if we need to embed this table in another page that makes use of the URL for something else? Or what if the URL is too long? We can keep refactoring and refactoring for every new requirement, but at the end of the day, you have to save the sorting options somewhere.</p>
<p>Of the three layers in MVC, the Model is the one that we really should be using for that. Note that the model layer doesn&#39;t necessarily need to save things to a database on the server. If we now go backwards cutting off requirements, we can make a model entity that saves to localStorage, or heck, even to just memory, if the application state is transient enough to be discardable at page unload.</p>
<p>If we structure our code this way from the beginning, then we have a clear API to use the application state in our controllers and views, and we can isolate the exact persistence implementation details to the model layer.</p>
<hr>
<h3 id="enter-view-models">Enter view models</h3>
<p>Some newer frameworks (most notoriously .NET MVC) introduce the concept of &quot;View Models&quot;, i.e. Model layer entities that exist exclusively to store UI state. They are different from traditional MVC models because by definition, they are tightly tied to specific view components.</p>
<p>Using a singleton is perhaps the simplest way of implementing a View Model:</p>
<pre><code class="lang-javascript">app.widget1State = {isPressed: m.prop(false)}

/*...*/
m(&quot;button&quot;, {
  onmousedown: function(){ app.widget1State.isPressed(true) },
  onmouseup: function(){ app.widget1State.isPressed(false) }
})
</code></pre>
<p>I use <code>m.prop</code> above to ensure we can refactor the View Model (here, the <code>m.prop</code> getter-setter is an in-memory data storage mechanism; we could later replace it with a custom getter-setter function that saves to localStorage, or the database server, or what have you, because it follows the <a href="the-uniform-access-principle.html">uniform access principle</a>)</p>
<p>View Models are meant to store application state (e.g. if there&#39;s a field and a cancel button, and we need to store the temporary value while editing), and regular Models are meant to store data state (e.g. the value after you save that field). You don&#39;t really want to store stuff like <code>valueBeforeEdit</code> and <code>currentValue</code> in your data model class; these are details that only exist because of the UI requirements for a cancel button and are not something that your data model should care about. Similarly, the sorting options of our sortable table and the flag for whether a panel is visible are both cases of application state, so they should live in a view model.</p>
<hr>
<h3 id="scoping-view-models">Scoping view models</h3>
<p>Normally, for complex pages, it might be tempting to make one big view model to drive the whole page, but it often makes more sense to scope one view model to each component on a page. It&#39;s not uncommon that you might need to reference one view model from an unrelated component, but these are uni-directional desired dependencies.</p>
<p>For example, if our sortable table has edit buttons that open up a modal dialog w/ a form, these buttons might set a value in the form&#39;s view model. However, this dependency is <em>desired</em> because we <em>want</em> the form dialog to be tied to the button. And since a view model is largely a data storage mechanism, we can still use it in other unrelated scenarios without worrying about the sortable table view model.</p>
<p>Having a single monolithic view model makes it harder to pull out components and reuse them elsewhere without bringing a lot of unrelated baggage with it.</p>
<hr>
<h3 id="conclusion">Conclusion</h3>
<p>Hopefully this essay can help you figure out where to put what kind of code. A lot of it is more a matter of understanding the MVC pattern and organizing the code in a pragmatic way, as opposed to inventing a &quot;Mithril way&quot; of forcing things to work around dogmatic assumptions that we bring over from our experiences with other frameworks. At the end of the day, the MVC pattern is supposed to be helping us, not getting in our way.</p>

			]]></description>
		</item>
		<item>
			<title>Velocity.js animations in Mithril</title>
			<link>http://lhorie.github.io/mithril-blog/velocity-animations-in-mithril.html</link>
			<description><![CDATA[
<h2 id="velocity-js-animations-in-mithril">Velocity.js animations in Mithril</h2>
<p>Some people have asked me how they could get animations to work with <a href="http://lhorie.github.io/mithril">Mithril</a>, so today we&#39;ll look at how to run some simple <a href="http://julian.com/research/velocity/">Velocity.js</a>-powered animations in Mithril templates.</p>
<p>Velocity.js is a library that allows us to run Javascript-based animations which perform on par with CSS transitions (and which work in IE). It&#39;s designed to be a drop-in replacement for jQuery&#39;s <code>animate</code> method, but it can also be used as a standalone library (i.e. without jQuery).</p>
<p>The easiest way to get started with it is to include a reference to it from a CDN:</p>
<pre><code class="lang-markup">&lt;script src=&quot;//cdn.jsdelivr.net/velocity/1.0.0/velocity.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>Calling Velocity as standalone library typically looks like this:</p>
<pre><code class="lang-javascript">Velocity(theElement, {opacity: 0})
</code></pre>
<p>The code above should hopefully be self-explanatory: it animates the opacity of an element from its current value to zero. So, assuming it started at <code>opacity: 1</code>, then it performs a fade-out effect.</p>
<p>Let&#39;s create a contrived mini-application so we can hook up some animations. First let&#39;s define some data:</p>
<pre><code class="lang-javascript">//model
var people = [
    {id: 1, name: &quot;John&quot;},
    {id: 2, name: &quot;Mary&quot;},
    {id: 3, name: &quot;Bob&quot;}
]
</code></pre>
<p>Next, let&#39;s create a view to display a list of people:</p>
<pre><code class="lang-javascript">//view
var view = function() {
    return m(&quot;ul&quot;, [
        people.map(function(person) {
            return m(&quot;li&quot;, person.name)
        })
    ])
}
</code></pre>
<p>And finally, let&#39;s add a bit of functionality: removing a person when its list item is clicked.</p>
<pre><code class="lang-javascript">//controller
var controller = function() {
    this.remove = function(person) {
        people.splice(people.indexOf(person), 1)
    }
}

//view
var view = function(ctrl) {
    return m(&quot;ul&quot;, [
        people.map(function(person) {
            return m(&quot;li&quot;, {
                key: person.id,
                onclick: ctrl.remove.bind(this, person)
            }, person.name)
        })
    ])
}
</code></pre>
<p>One thing to notice is that we added a <code>key</code> attribute to the <code>&lt;li&gt;</code>. This is usually good practice if you delete list items because it allows Mithril&#39;s virtual DOM diffing engine to be smarter about DOM reuse by providing referential metadata.</p>
<p>Putting it all together:</p>
<pre><code class="lang-javascript">//model
var people = [
    {id: 1, name: &quot;John&quot;},
    {id: 2, name: &quot;Mary&quot;},
    {id: 3, name: &quot;Bob&quot;}
]

//controller
var controller = function() {
    this.remove = function(person) {
        people.splice(people.indexOf(person), 1)
    }
}

//view
var view = function(ctrl) {
    return m(&quot;ul&quot;, [
        people.map(function(person) {
            return m(&quot;li&quot;, {
                key: id,
                onclick: ctrl.remove.bind(this, person)
            }, person.name)
        })
    ])
}

//run the app
m.module(document.body, {controller: controller, view: view})
</code></pre>
<p>As we saw earlier, in order to create an animation with Velocity, we need to pass a DOM element as the first argument. In Mithril, templates like the <code>view</code> function above are merely javascript functions that spit out javascript objects, but we can get a handle to the real DOM element by declaring a <code>config</code> attribute.</p>
<p>The <code>config</code> callback gets called after rendering occurs, when all the DOM elements generated by the template are guaranteed to be attached to the HTML document. It is meant to be used for arbitrary DOM manipulation.</p>
<pre><code class="lang-javascript">var fadesIn = function(element, isInitialized, context) {
    if (!isInitialized) {
        element.style.opacity = 0
        Velocity(element, {opacity: 1})
    }
}

var view = function(ctrl) {
    return m(&quot;ul&quot;, [
        people.map(function(person) {
            return m(&quot;li&quot;, {
                key: id,
                onclick: ctrl.remove.bind(this, person),
                config: fadesIn
            }, person.name)
        })
    ])
}
</code></pre>
<p>In the snippet above, we defined a new helper function called <code>fadesIn</code>, which we use as a <code>config</code> callback for the <code>li</code>. It sets the list item&#39;s opacity to zero, and then animates it back to 1 (i.e. it fades the element in)</p>
<p>The <code>element</code> argument is, as the name suggests, the <code>&lt;li&gt;</code> element.</p>
<p>The second argument, <code>isInitialized</code> is a flag that is set to false on initial rendering, and true for subsequent renders. As you can see, we used it to run the animation only when the element gets created, as opposed to running it every time a redraw occurs.</p>
<p>The third argument is an object that can be used to store element-specific data between redraws. You can <a href="http://lhorie.github.io/mithril/mithril.html#persisting-config-data">read more about it here</a></p>
<p>With this <code>config</code> callback in place, you should now see the list items fade in when the page loads.</p>
<hr>
<h2 id="what-about-fading-out-">What about fading out?</h2>
<p>Fading out is not that much harder to implement, but there&#39;s a cognitive dissonance caveat associated with it that often confuses people.</p>
<p>When Mithril redraws, views always look at the current state of the data to figure out what DOM elements should or should not be in the document. But fading out <em>after</em> removing an element from the model breaks that thought model: by definition, an animation starts and ends at different times, so if we remove a person from the list, the system would need to know somehow that its corresponding <code>&lt;li&gt;</code> element should stay in the document for the duration of the animation, even though the person was already removed from our data object at the beginning of the animation.</p>
<p>But because we&#39;re using a third-party library to integrate animations to Mithril, the framework would not be able to hide some of the complexities that come with the asynchronous nature of the animations. For example, what is the framework supposed to do with a DOM element if an animation is cancelled mid-way? Should it force you to rollback the deletion in the data model? Should it assume that you will clean up the DOM element manually? If you allow the framework to remove it for you, it might do it too early (e.g. if a redraw happens during a animation), but if you forget to remove it manually or mark it for removal, there&#39;s no way the system would know when to handle it, and the element would just sit there forever.</p>
<p>A simpler solution to this conundrum is to shift back in time and allow the animation to happen <em>before</em> the destructive data change happens, and <em>only then</em>, allow the removal of the person to happen atomically in our model layer. Here&#39;s a helper that runs the animation before the removal:</p>
<pre><code class="lang-javascript">var fadesOut = function(callback) {
    return function(e) {
        //don&#39;t redraw yet
        m.redraw.strategy(&quot;none&quot;)

        Velocity(e.target, {opacity: 0}, {
            complete: function() {
                //now that the animation finished, redraw
                m.startComputation()
                callback()
                m.endComputation()
            }
        })
    }
}
</code></pre>
<p>The snippet above defines a helper function called <code>fadesOut</code>, which returns an event handler that runs an animation, and then runs an arbitrary callback when the animation finishes.</p>
<p>The <code>m.redraw.strategy(&quot;none&quot;)</code> line tells Mithril that we don&#39;t want to redraw when the event handler returns (because at that point, nothing has changed yet).</p>
<p>The <code>complete</code> callback that we pass to Velocity.js is an asynchronous 3rd party callback, so there we call <code>m.startComputation</code> and <code>m.endComputation</code> to tell Mithril that we want to potentially redraw. Notice that we are not calling <code>m.redraw</code> because that function forces a redraw to happen immediately. We might conceivably want to run AJAX requests or other asynchronous operations in the <code>callback</code> function, so we need to use <code>m.startComputation</code> and <code>m.endComputation</code> to allow Mithril to wait for those asynchronous operations to complete.</p>
<p>Using the <code>fadesOut</code> helper is simple: just wrap it around the <code>remove</code> function.</p>
<pre><code class="lang-javascript">var view = function(ctrl) {
    return m(&quot;ul&quot;, [
        people.map(function(person) {
            return m(&quot;li&quot;, {
                key: id,
                onclick: fadesOut(ctrl.remove.bind(this, person)),
                config: fadesIn
            }, person.name)
        })
    ])
}
</code></pre>
<p>Now we have list items that fade in on page load, and fade out when we click on them. Here&#39;s the entire code so far.</p>
<pre><code class="lang-javascript">//model
var people = [
    {id: 1, name: &quot;John&quot;},
    {id: 2, name: &quot;Mary&quot;},
    {id: 3, name: &quot;Bob&quot;}
]

//controller
var controller = function() {
    this.remove = function(person) {
        people.splice(people.indexOf(person), 1)
    }
}

//view
var view = function(ctrl) {
    return m(&quot;ul&quot;, [
        people.map(function(person) {
            return m(&quot;li&quot;, {
                key: person.id,
                onclick: fadesOut(ctrl.remove.bind(this, person)),
                config: fadesIn
            }, person.name)
        })
    ])
}

//view helpers
var fadesIn = function(element, isInitialized, context) {
    if (!isInitialized) {
        element.style.opacity = 0
        Velocity(element, {opacity: 1})
    }
}
var fadesOut = function(callback) {
    return function(e) {
        //don&#39;t redraw yet
        m.redraw.strategy(&quot;none&quot;)

        Velocity(e.target, {opacity: 0}, {
            complete: function() {
                //now that the animation finished, redraw
                m.startComputation()
                callback()
                m.endComputation()
            }
        })
    }
}

//run the app
m.module(document.body, {controller: controller, view: view})
</code></pre>
<hr>
<h3 id="what-about-page-changes-">What about page changes?</h3>
<p>The code above works well for actions within a single page, but what if we want to run animations when jumping between routes?</p>
<p>As per the documentation, <code>config: m.route</code> is the <a href="http://lhorie.github.io/mithril/mithril.route.html#mode-abstraction">idiomatic way of creating routed links</a>, but there&#39;s nothing stopping us from using a custom <code>config</code> function instead, if we want to run animations before leaving a page. Here&#39;s how one might go about implementing it:</p>
<pre><code class="lang-javascript">//helper
var fadesOutPage = function(element, isInitialized, context) {
    if (!isInitialized) {
        element.onclick = function(e) {
            e.preventDefault()
            Velocity(document.getElementById(&quot;container&quot;), {opacity: 0}, {
                complete: function() {
                    m.route(element.getAttribute(&quot;href&quot;))
                }
            })
        }
    }
}

//in the templates
m(&quot;#container&quot;, {config: fadesIn}, [
    m(&quot;a[href=&#39;/foo&#39;]&quot;, {config: fadesOutPage}, &quot;go to foo&quot;)
])
</code></pre>
<p>As you can see, the code is strikingly similar what we have been doing before.</p>
<p>The <code>fadesIn</code> helper makes the page fade in when it loads, as it did before.</p>
<p>On the link, we defined an <code>onclick</code> handler that calls Velocity to run some animations on the container element and then redirect using m.route after the animation is done. One difference is that defining an event handler within a <code>config</code> callback doesn&#39;t require us to call <code>m.redraw.strategy(&quot;none&quot;)</code>. Recall that <code>config</code> is designed to be used for integrating non-Mithril code to Mithril templates, and in this case the <code>onclick</code> handler is just plain vanilla javascript, which doesn&#39;t do any auto-redrawing. In addition, we don&#39;t need to call <code>m.startComputation</code> and <code>m.endComputation</code> either because the <code>m.route()</code> redirect forces the page to redraw anyways.</p>
<p>Note that we could have used <code>onclick</code> as we did with <code>fadesOut</code>, instead of <code>config</code> - There&#39;s really no hard rules for whether you should use one or the other. In this article, I used <code>onclick</code> for <code>fadesOut</code> to make it clear that there&#39;s a cause-effect relationship between clicking and fading and removing a person, and I used <code>config</code> for <code>fadesOutPage</code> to make it look consistent with the way regular <code>{config: m.route}</code> links do. But as we saw, the default rendering strategy when we attach an <code>onclick</code> in the template required us to add some extra code to prevent auto-redrawing from happening in that particular event handler. The rule of thumb is that an <code>onclick</code> handler auto-redraws by default (for the sake of convenience in the data-model-updating case), whereas <code>config</code> has auto-redrawing turned off by default (for convenience in the free-reign-over-the-DOM case). As we saw, it&#39;s perfectly possible to change these defaults, so just use your best judgement to decide what option makes your code the most readable.</p>

			]]></description>
		</item>
		<item>
			<title>Extending the view language</title>
			<link>http://lhorie.github.io/mithril-blog/extending-the-view-language.html</link>
			<description><![CDATA[
<h2 id="extending-the-view-language">Extending the view language</h2>
<p>As you may know, <a href="http://lhorie.github.io/mithril">Mithril</a> is a pretty minimalist framework, which allows sugar functionality to be created by the community.</p>
<p>A recurring mantra in Mithril is that if something is too noisy or repetitive, you can put the verbosity in a function and call that instead. Today we&#39;ll look at a somewhat surprising extension point, but one that is extremely powerful: wrapping around the <code>m</code> method.</p>
<p>First let&#39;s create a basic wrapper:</p>
<pre><code class="lang-javascript">var mx = function(selector, attrs, children) {
    return m(selector, attrs, children)
}
</code></pre>
<p>As you can see, this doesn&#39;t really do anything new. The key here, though, is that it allows us to programmatically edit the attributes before creating the virtual dom element via <code>m</code>.</p>
<p>Let&#39;s create a simple collection of <em>attribute transformers</em>:</p>
<pre><code class="lang-javascript">var customAttrs = {
    cautions: function(callback) {
        this.onclick = function(e) {
            if (prompt(&quot;Are you sure?&quot;)) callback(e)
        }
    },
    toggles: function(flag) {
        if (!this.style) this.style = {}
        this.style.display = flag ? &quot;block&quot; : &quot;none&quot;
    }
}
</code></pre>
<p>An attribute transformer is simply a method that is meant to be called on a attribute that modifies it. In the example above, <code>cautions</code> adds an <code>onclick</code> handler that prompts the user before running a callback. <code>toggles</code> shows or hides an element based on a flag.</p>
<p>We can now extend <code>mx</code> to tap into our collection:</p>
<pre><code class="lang-javascript">var mx = function(selector, attrs, children) {
    for (var attrName in attrs) {
        if (customAttrs[attrName]) customAttrs[name].call(attrs, attrs[attrName]) 
    }
    return m(selector, attrs, children)
}
</code></pre>
<p>What we&#39;re doing in the code above is look for attribute names that exist in the <code>customAttrs</code> dictionary. If one does, we call that function using the <code>attrs</code> object as the <code>this</code> object.</p>
<p>Now we can easily bind our custom attribute transformers to a template:</p>
<pre><code class="lang-javascript">var buttonVisible = m.prop(false)
var myView = function() {
    return [
        m(&quot;a&quot;, {onclick: buttonVisible.bind(this, !buttonVisible())})
        mx(&quot;button&quot;, {toggles: buttonVisible, cautions: ctrl.selfDestruct}, &quot;Press if evil plans are foiled&quot;)
    ]
}
</code></pre>
<p>In the code above, the button becomes visible when the <code>buttonVisible</code> getter-setter is set to true, and on click, it prompts the user to confirm that they do, in fact, want to call <code>selfDestruct</code>.</p>
<hr>
<h3 id="handling-conflicts">Handling conflicts</h3>
<p>A clever reader might notice that this transformer suffers from one problem - it can clobber attributes. For example: </p>
<pre><code>mx(&quot;button&quot;, {cautions: ctrl.remove, onclick: ctrl.doSomethingElse}, &quot;Remove&quot;)
</code></pre><p>In the snippet above, <code>cautions</code> assigns a function to the <code>onclick</code> attribute, which means that <code>ctrl.doSomethingElse</code> does not run when we click on the button.</p>
<p>Fortunately, javascript is a dynamic language, which allows us to use <strong>monkeypatching</strong> to easily solve this problem:</p>
<pre><code class="lang-javascript">var monkeypatch = function(f1, f2) {
    return function() {
        var output1, output2
        if (typeof f1 == &quot;function&quot;) output1 = f1.apply(this, arguments)
        if (typeof f2 == &quot;function&quot;) output2 = f2.apply(this, arguments)

        //make compatible w/ event handler `return false` behavior
        return output1 === false || output2 === false ? false : undefined
    }
}
var customAttrs = {
    cautions: function(callback) {
        this.onclick = monkeypatch(this.onclick, function(e) {
            if (prompt(&quot;Are you sure?&quot;)) callback(e)
        })
    }
}
</code></pre>
<p>This preserves an existing <code>onclick</code> if it already exists, so that if the new <code>onclick</code> gets called, both the existing <code>onclick</code> and the callback run one after the other. We can easily tweak the order of execution for event handlers by simply changing the order of the parameters, and we can even replace <code>monkeypatch</code> altogether with different helpers to achieve more advanced event handler coordination (e.g. preventing a handler from running based on the return value of another.)</p>
<hr>
<h3 id="conclusion">Conclusion</h3>
<p>By wrapping around the <code>m</code> function, we are able to add custom functionality to templates using the same familiar syntax as regular HTML attributes.</p>
<p>Not only can we mix and match different units of functionality in a single DOM element, but we can also maintain control over how they interact with each other, even in the hairiest scenarios.</p>
<p><em>And this is only the beginning.</em> We saw that the <code>mx</code> wrapper we saw above only passes attributes to the list of transformers. But it&#39;s perfectly possible to expand this method and make it also introspect the <code>selector</code> parameter, as well as the virtual element that is returned from the wrapped <code>m</code> call, and even the children virtual elements, so we can create flexible transformers that act differently based on various criteria.</p>
<p>Here&#39;s an example that makes a good exercise to the reader: bi-directional bindings. Try creating a transformer called <code>binds</code>, which can read and write to a <code>m.prop</code> getter-setter, and that can correctly attach itself to a virtual element, considering that you need to read the <code>value</code> attribute in text inputs, but you need to read the <code>checked</code> attribute for checkboxes and radio boxes, and so on.</p>
<p>Or try writing one that replaces an empty child list with a &quot;there are no items&quot; text node. Or one that changes the output of the selector <code>a[href]</code>&#39;s into the equivalent of <code>[href=&quot;javascript:;&quot;]</code>. There&#39;s an endless amount of niceties that you can add to improve the developer ergonomics of the system.</p>
<p>And we can use the same system to add non-trivial functionality. The fact that we can tap into Mithril&#39;s <code>config</code> attribute from transformers means that, in addition to being able to modify virtual elements on the fly, we can also wrap around 3rd-party library integration boilerplate while keeping the ability of managing element lifecycles. In other words, we can have complex widgets with nice syntax. <em>And</em> we can still mixin transformers. <em>And</em> we still have the ability to <a href="when-css-lets-you-down.html">introspect and edit</a> components after inclusion if needed.</p>
<p>Before I leave you with this cool new technique, remember that with great power comes great responsibility. A wrapper&#39;s job is to hide complexity, and in this case there&#39;s two interfaces to consider: how we use the wrapper in templates and how easy it is to add transformers to the system. In addition, you also need to be aware of the cost of the wrapper&#39;s complexity itself. You are responsible for deciding how often your version of <code>mx</code> is called and how much &quot;magic&quot; that wrapper performs, given that the cost of the wrapper is multiplied by the number of times you call it.</p>
<p>Generally speaking, the cost of a wrapper - even a complex one - is surprisingly negligible. (Fun fact: Mithril&#39;s templating engine is fast even though <code>m()</code> uses regular expressions!) However, calling a carelessly slow implementation of <code>mx</code> for every element in a page that has tens of thousands of elements is bound to cause problems. If push comes to shove, there <em>are</em> ways to get around performance problems of that nature, but it&#39;s always better to put some thought in the design phase than to fix mistakes in the maintenance phase.</p>
<p>Anyways, I hope this article gives you some ideas on how to make your templates cleaner and your experience with Mithril templating even more pleasant.</p>

			]]></description>
		</item>
	</channel>
</rss>