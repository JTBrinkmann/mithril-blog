<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title>Mithril Blog</title>
		<description>A Javascript framework for building brilliant applications</description>
		<link>http://lhorie.github.io/mithril-blog/</link>
		<item>
			<title>Lessons learned from Angular</title>
			<link>http://lhorie.github.io/mithril-blog/lessons-learned-from-angular.html</link>
			<description><![CDATA[
{DOC}
			]]></description>
		</item>
		<item>
			<title>Curry flavored promises</title>
			<link>http://lhorie.github.io/mithril-blog/curry-flavored-promises.html</link>
			<description><![CDATA[
<h2 id="curry-flavored-promises">Curry flavored promises</h2>
<p><em>April 27, 2014</em></p>
<p>One aspect of <a href="http://lhorie.github.io/mithril">Mithril</a> that is pretty nice is that it allows us to use <a href="http://lhorie.github.io/mithril/mithril.deferred.html">promises</a>.</p>
<p>Promises are basically a mechanism that lets you chain a bunch of functions, which then get called asynchronously later when, say, an AJAX request completes:</p>
<pre><code class="lang-javascript">//a little helper function
var now = Date.now()
var pastItems = function(items) {
    return items.filter(function(item) {
        return item.date &lt; now
    });
};

//here&#39;s an AJAX request and a chain of promises
m.request({method: &quot;GET&quot;, url: &quot;/api/projects&quot;})
    .then(console.log) // log all projects
    .then(pastItems) // filter past projects
    .then(console.log) // log past projects only
</code></pre>
<p>Notice we&#39;re not calling <code>console.log()</code> nor <code>pastItems()</code>, but instead we&#39;re passing them to the promise&#39;s <code>.then()</code> method. What the code above does should be self-explanatory: it requests some projects, then logs them, then filters the list to only contain past projects, then logs the past projects. The one caveat that should be mentioned is that the only thing that happens immediately is the AJAX call. All the functions we passed to <code>.then</code> methods are only called at a later time, when the request completes.</p>
<p>Organizing our code as shown above is useful because it makes it easier for us to reuse code:</p>
<pre><code class="lang-javascript">m.request({method: &quot;GET&quot;, url: &quot;/api/vacations&quot;})
    .then(pastItems) // filter past vacations
    .then(console.log) // log past vacations
</code></pre>
<p>We can use the <code>pastItems</code> function to filter the result of a <code>vacations</code> web service (or any other web services) in addition to the projects one. Of course, we can also call the function directly if we have a list laying around that we want to filter.</p>
<p>We can mix and match code too:</p>
<pre><code class="lang-javascript">//another helper function
var createdByJohnDoe = function(items) {
    return items.filter(function(item) {
        return item.createdBy == &quot;John Doe&quot;
    });
};

m.request({method: &quot;GET&quot;, url: &quot;/api/projects&quot;})
    .then(pastItems) // filter past projects
    .then(createdByJohnDoe) // filter projects created by john doe
    .then(console.log) // log past projects created by john doe
</code></pre>
<p>A clever reader will probably notice that even though the code above is terse and modular, there is some room for improvement: The <code>createdByJohnDoe</code> function is not very reusable - we want to be able to filter by an arbitrary user, not just John Doe.</p>
<p>Fortunately, refactoring is easy. We can simply refactor our function to accept a <code>user</code> argument:</p>
<pre><code class="lang-javascript">var createdBy = function(user, items) {
    return items.filter(function(item) {
        return item.createdBy == user
    });
};
</code></pre>
<p>And then, we can <strong>curry</strong> this generic <code>createdBy</code> function to get the equivalent of <code>createdByJohnDoe</code> again:</p>
<pre><code class="lang-javascript">m.request({method: &quot;GET&quot;, url: &quot;/api/projects&quot;})
    .then(pastItems) // filter past projects
    .then(createdBy.bind(this, &quot;John Doe&quot;)) // filter projects created by john doe
    .then(console.log) // log past projects created by john doe
</code></pre>
<p>And voila! Curry flavored promises.</p>
<hr>
<h3 id="what-voodoo-magic-is-this-">What voodoo magic is this?</h3>
<p>Let&#39;s slow down a bit.</p>
<p>As we saw from the function definition earlier, <code>createdBy</code> can be called like this:</p>
<pre><code class="lang-javascript">var things = [
    {name: &quot;foo&quot;, createdBy: &quot;John Doe&quot;},
    {name: &quot;bar&quot;, createdBy: &quot;Jane Doe&quot;},
    {name: &quot;baz&quot;, createdBy: &quot;Mary Doe&quot;},
];
var byJohn = createdBy(&quot;John Doe&quot;, things); // [{name: &quot;foo&quot;, createdBy: &quot;John Doe&quot;}]
</code></pre>
<p>Currying is a functional programming technique that lets us pre-define arguments in a function. So <code>createdBy.bind(this, &quot;John Doe&quot;)</code> returns a function whose <code>user</code> argument is already set to &quot;John Doe&quot;. The <code>this</code> argument is, as you might have guessed, what the <code>this</code> should point to inside of the curried function. Since we don&#39;t actually use <code>this</code> in <code>createdBy</code>, this value doesn&#39;t actually matter for our purposes.</p>
<p>One subtle thing to notice is that the curried function can still take more arguments, which will be mapped to whatever is the first argument that is not yet bound via the curry. Therefore, the curried function can be called like this:</p>
<pre><code class="lang-javascript">var createdByJohnDoe = createdBy.bind(this, &quot;John Doe&quot;);

var byJohn = createdByJohnDoe(things); //[{name: &quot;foo&quot;, createdBy: &quot;John Doe&quot;}]
</code></pre>
<p>Whereas the signature of <code>createdBy</code> is <code>function(user, items)</code>, in the curried <code>createdByJohnDoe</code> function, the signature is simply <code>function(items)</code> because <code>user</code> is already present via an internal closure. Since <code>items</code> is the first argument of <code>createdByJohnDoe</code>, we can then pass this function to the promise&#39;s <code>.then()</code> method, which takes a function with signature <code>function(value)</code>, whose argument <code>value</code> is bound to the value being piped through the promise chain.</p>
<p>So in the same way that calling <code>.then(console.log)</code> is equivalent to the code below:</p>
<pre><code>.then(function(value) {
    console.log(value)
})
</code></pre><p>the same is true about the curried <code>createdByJohnDoe</code>. We can simply use the one-liner <code>.then()</code> calls as shown earlier, without the need to create the anonymous function.</p>
<p>Currying is a powerful technique that allows us to generalize and modularize our code, and then bring the pieces back together in a modular way.</p>
<p>This is one of the ways to avoid callback hell (i.e. zig-zaggy-indentation code made up of deeply nested callbacks), while at the same time enumerating the types of operations present in your app in a way that is easy to find, read and organize.</p>
<hr>
<h3 id="parting-thoughts">Parting thoughts</h3>
<p>I&#39;ll end this post with one last nugget: did you wonder why we are filtering projects on the client side? Usually it would make more sense to do so in the server (and more accurately, in the database server), but this is not always necessarily the case. Let&#39;s say that you do happen to have a full list of projects somewhere else in your app because it&#39;s something that the app deals with a lot. It&#39;s perfectly reasonable that your client-side model layer could cache that list, and that instead of re-fetching the data from the server, you could just tap into the client-side cache.</p>
<p>Since we are building an extensive arsenal of modular filter functions, we can just fetch the list once (maybe even put it in localStorage), and then slice and dice the cached list in a variety of ways without the need for a bunch of similar but just slightly different web service requests, and without the need to write a single extra line of SQL to support those slightly different requests.</p>
<p>So, you see, instead of spending all our time writing old style callback-driven code with lots of anonymous functions and a ton of custom SQL and other boilerplate code to support it, we can actually start spending time thinking of more efficient ways to deal with the data in our app in a much more comprehensive way. We can even start dreaming about things like offline apps.</p>
<p>Food for thought? Bon appetit!</p>

			]]></description>
		</item>
		<item>
			<title>Better templates with FP</title>
			<link>http://lhorie.github.io/mithril-blog/better-templates-with-fp.html</link>
			<description><![CDATA[
<h2 id="better-templates-w-fp">Better Templates w/ FP</h2>
<p><em>April 20, 2014</em></p>
<p>Every once in a while, when I start writing a new application, I create a page layout with a header and some navigation, and then some time later I need to have more than one page. Then I realize that the layout is hard coded and parts of it needs to be refactored out of my original page in order to avoid the need to copy and paste the global elements in every page. Sounds familiar?</p>
<p><a href="http://lhorie.github.io/mithril">Mithril</a> lets us take advantage of functional programming to create decoupled, composable templates - in other words, templates that you can mix and match.</p>
<p>For example, let&#39;s suppose we are building a site that has a menu and a body area:</p>
<pre><code class="lang-javascript">var layout = function() {
    return m(&quot;.layout&quot;, [
        m(&quot;header&quot;, [
            &quot;nav here&quot;
        ]),
        m(&quot;main&quot;, [
            &quot;body here&quot;
        ])
    ]);
};

m.module(document, {controller: function() {}, view: layout});
</code></pre>
<p>In case that code is not clear enough, here&#39;s what the output HTML looks like:</p>
<pre><code class="lang-markup">&lt;div class=&quot;layout&quot;&gt;
    &lt;header&gt;
        nav here
    &lt;/header&gt;
    &lt;main&gt;
        body here
    &lt;/main&gt;
&lt;/div&gt;
</code></pre>
<p>What we want to do is be able to dynamically define what <code>nav here</code> and <code>body here</code> are. In other words, we want a layout that looks like this:</p>
<pre><code class="lang-javascript">var layout = function(nav, body) {
    return m(&quot;.layout&quot;, [
        m(&quot;header&quot;, nav),
        m(&quot;main&quot;, body)
    ]);
};
</code></pre>
<p>And sub-templates that look like this:</p>
<pre><code class="lang-javascript">var nav = function() {
    return [
        &quot;nav here&quot;
    ];
};
var body = function() {
    return [
        &quot;body here&quot;
    ];
};
</code></pre>
<p>By organizing our code like this, the sub-templates don&#39;t need to be cluttered with explicit layout references, and the layout can flexibly render different navs and bodies as our app grows in complexity. In other words, organizing our code this way gives us nice and modular templates.</p>
<p>So all we need now is a glue to put together these nice modular pieces of code together.</p>
<p>Since functions are first class citizens in Javascript, we can create a <strong>higher order function</strong> - a function that works with functions - to do that for us:</p>
<pre><code class="lang-javascript">var mixinLayout = function(layout, nav, body) {
    return function() {
        return layout(nav(), body());
    };
};
</code></pre>
<p>All this function does is take templates as arguments (remember, Mithril templates are just functions), and then return a function that calls them (side note: the returned function is also a template).</p>
<p>And that&#39;s it! Now we can create as many layouts, navs and bodies as we want and we can put them together however we want to create our views:</p>
<pre><code class="lang-javascript">//here&#39;s a module
var myModule = {};
myModule.controller = function() { /*...*/ };
myModule.view = mixinLayout(layout, nav, body);

//here&#39;s another module
var anotherModule = {};
anotherModule.controller = function() { /*...*/ };
anotherModule.view = mixinLayout(layout, anotherNav, anotherBody);

//hook up our modules to routes
m.route(document, &quot;/foo&quot;, {
    &quot;/foo&quot;: myModule,
    &quot;/bar&quot;: anotherModule
});
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced usage</h3>
<p>This technique becomes very powerful when using <a href="http://lhorie.github.io/mithril/components.html">components</a> to organize code. For example, you might have a widget that lives in its own page (e.g. a login widget), but this widget may also appear in a modal dialog somewhere else in the site.</p>
<p>By writing the login widget&#39;s template as a self-contained function as we saw above, we can attach a layout for the standalone login page, and we can just include the naked template as a component in our modal dialog. No copy-pasta required.</p>
<pre><code class="lang-javascript">//the widget template
var loginWidget = function() {
    return [
        m(&quot;input[placeholder=&#39;Username&#39;]&quot;),
        m(&quot;input[placeholder=&#39;Password&#39;][type=&#39;password&#39;]&quot;),
        m(&quot;button&quot;)
    ]
}

//standalone page
var loginPage = {}
loginPage.controller = function() { /*...*/ }
loginWidget.view = mixinLayout(layout, nav, loginWidget)

//as a component in another part of the app
var anotherPlace = {}
anotherPlace.controller = function() { /*...*/ }
anotherPlace.view = function() {
    return [
        &quot;stuff before&quot;,
        loginWidget(),
        &quot;stuff after&quot;
    ]
}
</code></pre>
<p>It&#39;s worth noting that even though I call this an example of &quot;advanced usage&quot; and throw around fancy words like &quot;components&quot;, the code itself is actually surprisingly straightforward.</p>
<p>Hopefully this article sheds some light into ways to keep templates DRY, and how Mithril&#39;s simplicity can help achieve that goal.</p>

			]]></description>
		</item>
		<item>
			<title>Building a "Seinfeld" App</title>
			<link>http://lhorie.github.io/mithril-blog/building-a-seinfeld-app.html</link>
			<description><![CDATA[
<h2 id="building-a-seinfeld-app">Building a &quot;Seinfeld&quot; App</h2>
<p><em>April 13, 2014</em></p>
<p>To-do apps have become the &quot;hello world&quot; of javascript frameworks; they are easy to build and just structured enough to be a good showcase of framework features.</p>
<p>Today we&#39;re going to take that one step further and use <a href="http://lhorie.github.io/mithril">Mithril</a> to build something that is a little bit more focused and a little bit more useful.</p>
<p>You may have heard of the <a href="http://lifehacker.com/281626/jerry-seinfelds-productivity-secret">&quot;don&#39;t break the chain&quot; concept, made famous by comedian Jerry Seinfeld</a>. The gist is this: if there&#39;s an activity you want to turn into a habit, get a calendar and put an &quot;X&quot; on every day that you do it. The goal is to have a lot of consecutive &quot;X&quot;s, with no gaps, hence &quot;don&#39;t break the chain&quot;.</p>
<p>The rationale behind this is that a lot of people have trouble sticking with something for long periods of time due to lack of focus or prioritization tools or whatever. Seinfeld&#39;s trick just makes use of gamification to nudge us to be more persistent than we perhaps would be without the aid of a tool. So that&#39;s what we&#39;re gonna build.</p>
<hr>
<h3 id="view-layer">View layer</h3>
<p>Let&#39;s start by creating an HTML file:</p>
<pre><code class="lang-markup">&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Don&#39;t break the chain&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;mithril.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
        //app goes here
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>There&#39;s really no consensus on the number of days needed to actually form a habit, so let&#39;s just build a 7x7 grid because 7 days per week is familiar and squares are pretty.</p>
<p>Here&#39;s what we might want our grid template to look like:</p>
<pre><code class="lang-javascript">//our app&#39;s namespace
var chain = {};

//model goes here

//controller goes here

//view
chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function() {
        return m(&quot;tr&quot;, chain.seven(function() {
            return m(&quot;td&quot;, [
                m(&quot;input[type=checkbox]&quot;)
            ]);
        });
    });
};
</code></pre>
<p>If you were coding along, you would probably notice that typing 7 table rows and 7 columns per row would result in a pretty big and repetitive template. So what we did above is define a <strong>stub</strong> method called <code>chain.seven</code> which will repeat whatever you pass to it 7 times. </p>
<p>Stubbing basically means just calling a function that doesn&#39;t exist yet. It&#39;s a great way of cranking out some code quickly: it helps mitigate &quot;analysis paralysis&quot; by letting you focus on the easy stuff (i.e. the general DOM structure), so you can worry about the repetition stuff in isolation later.</p>
<p>Note that implementing <code>chain.seven</code> is an easy-to-complete task, so it makes for a good warm-up task to get the juices going if you were to stop working on this app now and came back to work on it tomorrow. This is a powerful productivity trick: if you&#39;re getting bogged down, just write a stub and move on! It helps you shift away from the all-or-nothing approach to development that stalls a lot of people and nudges you towards incremental progress. </p>
<p>Now that we have do have our basic grid structure figured out, we can get the <code>chain.seven</code> utility out of the way:</p>
<pre><code class="lang-javascript">//create a helper utility that we can use in the view
chain.seven = function(subject) {
    var output = [];
    for (var i = 0; i &lt; 7; i++) output.push(subject(i));
    return output;
};
</code></pre>
<p>Note that we pass the iteration index <code>i</code> as a parameter to the <code>subject</code> callback. This will be useful later.</p>
<p>It&#39;s worth noting that KISS (&quot;keep it simple, stupid&quot;) is a strong driving principle in Mithril. Note how we didn&#39;t need to look up any framework APIs to create the <code>chain.seven</code> extension to our view language. It&#39;s just plain javascript. We can quickly make our templates as expressive and application-specific as we want.</p>
<p>Combined w/ techniques like stubbing, you can write code almost as fast as it appears in your mind, and rely on your console&#39;s null reference exceptions as a running &quot;todo list&quot; of sorts.</p>
<p>Now that we have a basic template setup, we can render it to see what it looks like:</p>
<pre><code class="lang-javascript">//our app&#39;s namespace
var chain = {};

chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function() {
        return m(&quot;tr&quot;, chain.seven(function() {
            return m(&quot;td&quot;, [
                m(&quot;input[type=checkbox]&quot;)
            ]);
        }));
    }));
};

//create a helper utility that we can use in the view
chain.seven = function(subject) {
    var output = [];
    for (var i = 0; i &lt; 7; i++) output.push(subject(i));
    return output;
};

//render it
m.module(document.body, {controller: function() {}, view: chain.view});
</code></pre>
<hr>
<h3 id="model-layer">Model layer</h3>
<p>Now we can start thinking about functionality. Our app is pretty simple: all we need to do is make checkboxes retain their states after they&#39;ve been checked.</p>
<p>Since it&#39;s highly unlikely that anyone is ever going to keep the app running for days on end, we need a persistence layer. The simplest thing we can use is <code>LocalStorage</code>. It doesn&#39;t work in older browsers, but we don&#39;t want to get bogged down setting up a database for a tutorial app that we&#39;re probably only going to use in our own smartphones, so it&#39;s adequate enough.</p>
<p>The LocalStorage API is pretty straightforward. If you add a property to the <code>localStorage</code> object, its value is cast to a string:</p>
<pre><code class="lang-javascript">localStorage.test = 1 // &quot;1&quot;
localStorage.foo = [1, 2, 3] // &quot;1,2,3&quot;
localStorage.bar = {a: 1} // &quot;[object Object]&quot;
</code></pre>
<p>Our app consists of 49 days, which can be either marked with an &quot;X&quot;, or not. So what we need to do is persist a list of booleans. Since LocalStorage has no concept of fetching a subset of a data list, the simplest storage implementation would be something like this:</p>
<pre><code>//a list model API
chain.save = function(list) {
    localStorage[&quot;chain-app.list&quot;] = JSON.stringify(list);
};
chain.load = function() {
    return JSON.parse(localStorage[&quot;chain-app.list&quot;] || &quot;[]&quot;);
};
</code></pre><p>This API can be used like this:</p>
<pre><code class="lang-javascript">var list = chain.load();
list[42] = true; //set the 42nd day
chain.save(list);

//reset the list
chain.save([]);
</code></pre>
<p>In addition to the actual list of checks, we also need to know when our chain started. So we also need an auxiliary model entity to store the start date.</p>
<pre><code class="lang-javascript">//a date model API
chain.today = function() {
    var now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
}
chain.resetDate = function() {
    return localStorage[&quot;chain-app.start-date&quot;] = chain.today().getTime();
}
chain.startDate = function() {
    return new Date(parseInt(localStorage[&quot;chain-app.start-date&quot;] || chain.resetDate()));
}
chain.dateAt = function(index) {
    var date = new Date(chain.startDate());
    date.setDate(date.getDate() + index);
    return date;
}
</code></pre>
<p>This API can be used like this:</p>
<pre><code class="lang-javascript">var today = chain.today() //today at midnight

var startDate = chain.startDate(); //start date is today

var isToday = chain.dateAt(3).getTime() === chain.today() //is three days from now the same as today? Should be false

//reset
var newStartDate = chain.resetDate(); //new start date is today
</code></pre>
<p>Again, note how we didn&#39;t need to use any framework code in the model layer. We could have used classes, but we&#39;re just creating an API without them to illustrate the point that it&#39;s perfectly possible to maintain the MVC pattern while prototyping, without the need for bureaucracy. As long as our APIs are simple and well defined, we can always refactor later.</p>
<hr>
<h3 id="controller-layer">Controller layer</h3>
<p>In Mithril, controllers are typically meant to be the glue between the model and view layer. Here&#39;s one way to implement it:</p>
<pre><code class="lang-javascript">chain.controller = function() {
    var list = chain.load();

    this.isChecked = function(index) {
        return list[index]
    };
    this.check = function(index, status) {
        if (chain.dateAt(index).getTime() &lt;= chain.today().getTime()) {
            list[index] = status;
            chain.save(list);
        }
    };
};
</code></pre>
<p>Our controller doesn&#39;t actually expose the raw list from the model. Instead it implements a <code>isChecked</code> method to read the state for a given day, and a <code>check</code> method to set it (with some validation to prevent setting days in the future).</p>
<p>With this API, we are able to expose all the model data that we need to the view. Below is an example of how this controller API can be used:</p>
<pre><code class="lang-javascript">var ctrl = new chain.controller();

var isFirstDayChecked = ctrl.isChecked(0); //is first day checked?

ctrl.check(0, true); //check off the first day
</code></pre>
<p>Now that we have a controller attached to our namespace, we can actually use it as a Mithril module, i.e. we can just pass the namespace object wholesale to Mithril initializer method:</p>
<pre><code class="lang-javascript">//call this at the end of the code to initialize the `chain` app
m.module(document.body, chain);
</code></pre>
<p>With this call, the controller gets instantiated and this instance is passed to the view as a parameter (the <code>ctrl</code> argument of the <code>view</code> function).</p>
<hr>
<h3 id="putting-it-all-together">Putting it all together</h3>
<p>Now all we need to do is make the view layer dynamically load the data that we exposed via the controller. Normally, this is done in frameworks via what are called <strong>bi-directional data bindings</strong>.</p>
<p>A bi-directional data binding is really just a fancy way of saying that a DOM element has code attached to it that sets its value based on our model data, and an event handler to update the model data when a UI change happens.</p>
<p>Here&#39;s a simple binding helper function: it returns the set of attributes needed to do bi-directional data binding based on a controller instance and an model layer&#39;s list index.</p>
<pre><code class="lang-javascript">chain.checks = function(ctrl, index) {
    return {
        onclick: function() {
            ctrl.check(index, this.checked);
        },
        checked: ctrl.isChecked(index)
    };
}
</code></pre>
<p>Now we can use this binding in the template we created at the beginning:</p>
<pre><code class="lang-javascript">chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function(y) {
        return m(&quot;tr&quot;, chain.seven(function(x) {
            return m(&quot;td&quot;, [
                m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, chain.indexAt(x, y)))
            ]);
        }));
    }));
};
</code></pre>
<p>If you have been paying attention you probably noticed that we just defined another stub called <code>chain.indexAt</code>: our template doesn&#39;t expose the raw offset that we need for our model API, but the <code>chain.seven</code>&#39;s callback argument can be used to compute it.</p>
<p><code>chain.indexAt(x, y)</code> will need to take a grid position and return the appropriate flat-list index, assuming that the days are counted like in a regular calendar.</p>
<pre><code class="lang-javascript">chain.indexAt = function(x, y) {
    return y * 7 + x;
}
</code></pre>
<p>This should be enough to make the UI dynamic: you should be able to check off a box, refresh the page and see that it retained its state.</p>
<p>Before we continue, let me just me a note about data bindings. Most frameworks have generic binding syntax, but they&#39;re often prescriptive and inflexible.</p>
<p>Creating our own custom bindings like we did above has a lot of advantages: we can have super expressive code that reads almost like prose - <code>m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, chain.indexAt(x, y)))</code> is roughly &quot;a checkbox that checks the index that corresponds to these x and y coordinates&quot;</p>
<p>In addition, we can maintain full control over the implementation, and we can keep these implementation details neatly tucked in the view layer, rather than pollute the controller layer or having to create other complexity layers.</p>
<hr>
<p>One last thing we can do to make the app more usable is highlight the checkbox that corresponds to the current day. Let&#39;s write another data binding for this:</p>
<pre><code class="lang-javascript">chain.highlights = function(index) {
    return {
        style: {
            background: chain.dateAt(index).getTime() == chain.today().getTime() ? &quot;silver&quot; : &quot;&quot;
        }
    };
};
</code></pre>
<p>Notice that this binding is not bi-directional - it doesn&#39;t need an event handler. All it does is set a background color based on whether the cell corresponds to today.</p>
<p>We can then refactor our view to use our new binding:</p>
<pre><code class="lang-javascript">chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function(y) {
        return m(&quot;tr&quot;, chain.seven(function(x) {
            var index = chain.indexAt(x, y)
            return m(&quot;td&quot;, chain.highlights(index), [
                m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, index))
            ]);
        }));
    }));
};
</code></pre>
<p>This last binding is noteworthy for a few reasons: for one thing, it illustrates how we can easily tuck away noisy template snippets - I mean, really, who likes inline style attributes? :)</p>
<p>Another thing to notice is that despite this snippet being part of the view layer (conceptually), it accesses the model directly (it calls <code>chain.today</code>) without going through the controller. Logically, the concept of &quot;today&quot; doesn&#39;t need class instantiation management, so it&#39;s perfectly reasonable to skip controller bureaucracy for it altogether.</p>
<p>The last thing to note is that because our views are plain javascript, things like caching computed values (<code>var index</code> in our case) are easy to do and completely transparent, so it&#39;s highly unlikely that you would ever run into <a href="http://stackoverflow.com/questions/14376879/error-10-digest-iterations-reached-aborting-with-dynamic-sortby-predicate">bizarre problems</a>.</p>
<hr>
<h3 id="conclusion">Conclusion</h3>
<p>This is pretty much all we need to have a working app. Here&#39;s the code in its entirety:</p>
<pre><code class="lang-javascript">&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Don&#39;t break the chain&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;mithril.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
//our app&#39;s namespace
var chain = {};

//model
chain.save = function(list) {
    localStorage[&quot;chain-app.list&quot;] = JSON.stringify(list);
};
chain.load = function() {
    return JSON.parse(localStorage[&quot;chain-app.list&quot;] || &quot;[]&quot;);
};

chain.today = function() {
    var now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
}
chain.resetDate = function() {
    return localStorage[&quot;chain-app.start-date&quot;] = chain.today().getTime();
}
chain.startDate = function() {
    return new Date(parseInt(localStorage[&quot;chain-app.start-date&quot;] || chain.resetDate()));
}
chain.dateAt = function(index) {
    var date = new Date(chain.startDate());
    date.setDate(date.getDate() + index);
    return date;
}



//controller
chain.controller = function() {
    var list = chain.load();

    this.isChecked = function(index) {
        return list[index]
    };
    this.check = function(index, status) {
        if (chain.dateAt(index).getTime() &lt;= chain.today().getTime()) {
            list[index] = status;
            chain.save(list);
        }
    };
};



//view
chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function(y) {
        return m(&quot;tr&quot;, chain.seven(function(x) {
            var index = chain.indexAt(x, y)
            return m(&quot;td&quot;, chain.highlights(index), [
                m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, index))
            ]);
        }));
    }));
};

chain.seven = function(subject) {
    var output = [];
    for (var i = 0; i &lt; 7; i++) output.push(subject(i));
    return output;
};

chain.checks = function(ctrl, index) {
    return {
        onclick: function() {
            ctrl.check(index, this.checked);
        },
        checked: ctrl.isChecked(index)
    };
};

chain.highlights = function(index) {
    return {
        style: {
            background: chain.dateAt(index).getTime() == chain.today().getTime() ? &quot;silver&quot; : &quot;&quot;
        }
    };
};

chain.indexAt = function(x, y) {
    return y * 7 + x;
}

//render it
m.module(document.body, chain);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>From here, you can start adding polish to the app: <a href="http://stackoverflow.com/questions/8195741/how-do-they-do-this-mobile-site-added-to-homescreen-appears-as-standalone-app">making it &quot;Add to Home Screen&quot; friendly</a>, maybe <a href="http://webdesign.tutsplus.com/tutorials/quick-tip-easy-css3-checkboxes-and-radio-buttons--webdesign-8953">styling the checkboxes</a>, or just using a CSS framework like <a href="http://getbootstrap.com/">Bootstrap</a> for a quick improvement in look and feel, etc.</p>
<hr>
<h3 id="homework">Homework</h3>
<p>You probably noticed that this app doesn&#39;t let you write down what is the actual activity that you are tracking. Adding a text input that lets you do so and saves this text to <code>localStorage</code> is a good homework assignment to solidify all the important concepts we covered in the article.</p>
<p>Another feature that you should try to add is a button to reset the app (after all, an app that becomes useless after 49 days is no fun.)</p>
<p>If you want to build more experience with real life coding, another thing you can do is take this app and improve it so that you can track more than one activity. This is a great exercise for reading existing code and refactoring, as well as learning more about useful <a href="http://lhorie.github.io/mithril">Mithril</a> features.</p>
<p>Remember that if you need help or have questions, you are always welcome to post in the <a href="https://groups.google.com/forum/#!forum/mithriljs">mailing list</a> or send me an <a href="https://github.com/lhorie/">email</a>.</p>

			]]></description>
		</item>
		<item>
			<title>Giving Mithril a voice</title>
			<link>http://lhorie.github.io/mithril-blog/giving-mithril-a-voice.html</link>
			<description><![CDATA[
<h2 id="giving-mithril-a-voice">Giving Mithril a voice</h2>
<p><em>April 11, 2014</em></p>
<p>I released Mithril last month and the project has been getting generally positive feedback and some <a href="https://github.com/jpmonette/todomvc-mithril">good</a> <a href="https://github.com/insin/msx">traction</a>.</p>
<p>There&#39;s still a lot of things I want to share with people that aren&#39;t necessarily core Mithril features, be them interesting application developement techniques, or my own experience w/ development and even open source in general, so today I&#39;m launching this blog.</p>
<p>To give a recap of what&#39;s been happening since launch, Mithril is now a lot more accessible, being <a href="http://lhorie.github.io/mithril/installation.html">available from CDNs, and popular NodeJS package managers</a>.</p>
<p>In addition to this blog, the <a href="https://groups.google.com/forum/#!forum/mithriljs">mailing list</a> and the <a href="https://github.com/lhorie/mithril.js/issues?state=open">Github issue tracker</a> are great places to start conversations.</p>
<p>On the plumbing end, Mithril is now on Travis CI, and the test suite is rapidly growing. It now includes regression tests for reported bugs to ensure a stable core.</p>
<p>For the next little while, I&#39;m hoping to nail down all the lingering bugs that contributors have been finding (particularly around the <code>m.render</code> method). Once I feel it&#39;s stable enough to bump Mithril to a v0.2, I&#39;ll have the chance to start putting more time on the plugin ecosystem, which has a really exciting pipeline: more readable and expressive templates, advanced optimization tools, a more wholesome approach to dependency management, etc - and hopefully no changes to the core codebase in order to support all of this :)</p>
<p>If you&#39;re liking Mithril, you can help in a few different ways. The easiest is to spread the word. Another way is to try it out and report any bugs you find. You&#39;re also welcome to post topics in the mailing list or get in touch with me directly.</p>
<p>If you want a project to take on, there&#39;s a lot of stuff that can be done in terms of plugins, and if you need help getting started, I&#39;m more than happy to help get the ball moving for you. <a href="https://github.com/lhorie/mithril.js/issues/38">This thread</a>, for example is a good starting point.</p>
<p>In the coming weeks, I&#39;m hoping to start writing more topics about actual development, both in general, and as it relates to Mithril, so stay tuned :)</p>

			]]></description>
		</item>
	</channel>
</rss>