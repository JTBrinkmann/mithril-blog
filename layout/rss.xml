<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title>Mithril Blog</title>
		<description>A Javascript framework for building brilliant applications</description>
		<link>http://lhorie.github.io/mithril-blog/</link>
		<item>
			<title>Asymmetrical data bindings</title>
			<link>http://lhorie.github.io/mithril-blog/asymmetrical-data-bindings.html</link>
			<description><![CDATA[
{DOC}
			]]></description>
		</item>
		<item>
			<title>What's in a namespace</title>
			<link>http://lhorie.github.io/mithril-blog/whats-in-a-namespace.html</link>
			<description><![CDATA[
<h2 id="what-s-in-a-namespace">What&#39;s in a namespace</h2>
<p>In Mithril examples, I often use modules interchangeably as namespaces:</p>
<pre><code class="lang-javascript">//a namespace
var app = {};

app.controller = function() {
    this.greeting = &quot;hello&quot;;
};

app.view = function(ctrl) {
    return m(&quot;h1&quot;, ctrl.greeting);
};

m.module(document.body, app);
</code></pre>
<p>But the reality is that this 1-to-1 mapping between modules and namespaces isn&#39;t strictly required. In this article we&#39;ll look at different ways of organizing code and why you might want to choose one way over another.</p>
<h3 id="vertical-namespaces">Vertical namespaces</h3>
<p>This is what we just saw in the snippet above: each module is its own namespace, i.e. a namespace object contains a <code>controller</code> and a <code>view</code> properties. The namespace object might also contain helper functions and auxiliary model entities. This organization style is good when modules are self-contained units of functionality.</p>
<p>For example, you might have a login page, a registration page and a user dashboard. Typically, for the purposes of development, each of these pages can be thought of as a standalone part of the application, and from a high-level perspective, it makes sense to have a <code>login</code> module, a <code>registration</code> module and a <code>dashboard</code> module.</p>
<p>Trivial example apps are another use case where modules as namespaces are appropriate: a single namespacing module is a good middle ground to hold the entirety of our application without the bureaucracy of numerous namespaces and without polluting the global scope.</p>
<h3 id="horizontal-namespaces">Horizontal namespaces</h3>
<p>Another way of organizing code is to namespace things based on the layer where they live:</p>
<pre><code class="lang-javascript">//controllers namespace
var controllers = {};

controllers.GreetingCtrl = function() {
    this.greeting = &quot;hello&quot;;
};

//views namespace
var views = {};

views.greetingView = function(ctrl) {
    return m(&quot;h1&quot;, ctrl.greeting);
};

m.module(document.body, {controller: controllers.GreetingCtrl, view: views.greetingView});
</code></pre>
<p>This organization style is appropriate when there&#39;s a lot of repetition somewhere. For example, financial applications often have a large number of paginated, filterable tables. We might have a table view, a filters view and a pagination view that get reused several times in different parts of the application. In applications like this, where we expect a high degree of code reusability, it&#39;s often awkward to map the reusable pieces to a neat one-controller-to-one-view paradigm.</p>
<p>This style can also be more suitable when there&#39;s a large amount of scope creep or ad-hoc development, since in those cases, it&#39;s common that multiple existing pieces of functionality might get combined to support new features (i.e. &quot;can we also put thing X as a sidebar panel here&quot;).</p>
<h3 id="quick-and-dirty">Quick and dirty</h3>
<p>One other way to organize code is to not structure it at all:</p>
<pre><code class="lang-javascript">var GreetingCtrl = function() {
    this.greeting = &quot;hello&quot;;
};

var greetingView = function(ctrl) {
    return m(&quot;h1&quot;, ctrl.greeting);
};

m.module(document.body, {controller: GreetingCtrl, view: greetingView});
</code></pre>
<p>Notice that in this example, there are no namespaces - instead we construct an anonymous module when we call <code>m.module</code>.</p>
<p>There are some obvious weaknesses with this approach: we need to rely heavily on naming conventions to avoid collisions, and everything lives in the global scope (although you could put your code in an application-level namespace to prevent global scope pollution). But conversely, the lack of structure means that there&#39;s no namespacing verbosity when referencing arbitrary pieces of functionality from arbitrary places, so this style is suitable for exploratory coding and for hacking up quick prototypes, where we&#39;re not sure how pieces might end up coming together. Due to the reliance on naming conventions, this style is also grep-friendly: if we do need to organize code more formally down the road, we can search and replace things by name more easily than if our code used a mix of namespace objects and clever usage of the <code>this</code> keyword.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Applications are not created equal, so it makes sense that we should have flexibility when organizing our code. The structure of sample code in the Mithril docs and here on the blog might appear to suggest that code should always fit neatly in a module, but Mithril itself doesn&#39;t actually impose any specific way of doing things.</p>
<p>It&#39;s always a good idea to take the time to think about the reusability profile of your application, so you can organize code in a way that makes sense for you. </p>

			]]></description>
		</item>
		<item>
			<title>When CSS lets you down</title>
			<link>http://lhorie.github.io/mithril-blog/when-css-lets-you-down.html</link>
			<description><![CDATA[
<h2 id="when-css-lets-you-down">When CSS lets you down</h2>
<p>Componentization is a framework&#39;s ability to split the UI into pieces that are modular and reusable. So it&#39;s no wonder that many people are working hard in creating systems for providing this ability to developers: the Web Component spec, and the newest alpha releases of Knockout.js are good examples.</p>
<p>Speaking from my experience, I think there&#39;s one fundamental problem with the way componentization is commonly done: and it can be summarized in one word - CSS.</p>
<p>Component systems are great at encapsulating functionality, but the downside is that we also lose the ability to look into them and modify them - Web Component proponents often say that we can style shadow DOMs with CSS, but those with experience trying to customize the design of jQuery-UI or Ext.js widgets (and by customize I mean change their layouts to the specs of a 3rd party graphics designer, not merely change colors and trivial CSS rules) knows that certain things are extremely hard (or even downright impossible) to do. Things like vertical alignment and arbitrary ordering of elements are poorly supported by CSS, and the presence of non-editable javascript-generated inline styles, for example, further complicates matters.</p>
<p>Unfortunately, despite the promise of separation of content and styles that CSS was meant to solve, the reality is that some design aspects still require us to modify HTML. And the systems that encapsulate markup in order to provide modularity forget that too often.</p>
<p>Mithril templates, being simply pure functions that return plain javascript data structures, can be piped to <strong>transformer functions</strong>, which allows the developer to maintain control over their component&#39;s markup and styles with a deep level of granularity.</p>
<p>Here&#39;s a simple example to demonstrate. Imagine we need to display some tabular data. Our template would likely look something like this.</p>
<pre><code class="lang-javascript">//a simple template
function table(ctrl) {
    return m(&quot;table&quot;, [
        m(&quot;tr&quot;, [
            m(&quot;th&quot;, &quot;Project&quot;),
            m(&quot;th&quot;, &quot;Budget&quot;),
            m(&quot;th&quot;, &quot;Actuals&quot;)
        ]),
        m(&quot;tr&quot;, [
            ctrl.data.map(function(item) {
                return [
                    m(&quot;td&quot;, item.name),
                    m(&quot;td&quot;, item.budget),
                    m(&quot;td&quot;, item.actuals)
                ]
            })
        ])
    ]);
};
</code></pre>
<p>The code above is simply a table that loops through a list of data and renders a row for each item in the list. It would render something like this:</p>
<pre><code class="lang-markup">&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;th&gt;Budget&lt;/th&gt;
        &lt;th&gt;Actuals&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Bike Ad Campaign&lt;/td&gt;
        &lt;td&gt;$100,000&lt;/td&gt;
        &lt;td&gt;$97,000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Cart Ad Campaign&lt;/td&gt;
        &lt;td&gt;$80,000&lt;/td&gt;
        &lt;td&gt;$82,000&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>If we needed to style our table with, say, Bootstrap, we&#39;d manually add a CSS class to it. But if the table needed to be sortable or have some other not-so-trivial functionality and we chose to use a 3rd party component, we either need to search the Googles for a component that already uses Bootstrap, or spend way too much time re-styling a component&#39;s built-in style ourselves.</p>
<p>With a transformer function, we can programmatically inject the CSS classes that we need into our template. Mithril&#39;s <code>m</code> utility returns a <em>virtual element</em> object that looks like this:</p>
<pre><code class="lang-javascript">{tag: &quot;div&quot;, attrs: {class: &quot;foo&quot;}, children: [ /* child objects */ ]}
</code></pre>
<p>Knowing that, we can create a function that takes the tree of virtual elements from our <code>table</code> function as a parameter, and transform it using plain javascript:</p>
<pre><code class="lang-javascript">//transformer function: simply add the `table` CSS classes to the table
function styleTable(table) {
    table.attrs.class = &quot;table table-striped&quot;;
    return table;
};

//pipe our table template
styleTable(table(ctrl));
</code></pre>
<p>Then our rendered template would have bootstrap classes attached:</p>
<pre><code class="lang-markup">&lt;table class=&quot;table table-striped&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;th&gt;Budget&lt;/th&gt;
        &lt;th&gt;Actuals&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Bike Ad Campaign&lt;/td&gt;
        &lt;td&gt;$100,000&lt;/td&gt;
        &lt;td&gt;$97,000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Cart Ad Campaign&lt;/td&gt;
        &lt;td&gt;$80,000&lt;/td&gt;
        &lt;td&gt;$82,000&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>With this technique in hand, a component author no longer needs to hard-code the CSS classes of their components into their templates, and developers that use those components can roll their own transformers as well.</p>
<p>Transformer functions aren&#39;t limited to simply adding classes to particular elements. We can even modify the tree structure of a template, so we can do things like control the ordering of DOM elements and add helper spans to apply CSS position or overflow, when needed.</p>
<p>We can modify the virtual element tree structure with confidence because, unlike with jQuery code, we have the data model decoupled from the DOM tree, and no runtime DOM traversal happening, so we don&#39;t need to worry about components&#39; internal DOM traversal code breaking after we change the DOM tree.</p>
<h3 id="advanced-transformers">Advanced transformers</h3>
<p>A clever reader might realize that writing transformer functions for non-trivial templates can be brittle if we naively use dot notation to traverse down the virtual element tree. But because templates are just javascript data structures, we can get around this issue using techniques like <strong>recursive pattern matching</strong></p>
<p>Javascript unfortunately doesn&#39;t have built-in syntax for compile-time pattern matching in the way that languages like Haskell do, but it&#39;s perfectly possible to do runtime pattern matching using procedural code. Here&#39;s a simple example:</p>
<pre><code class="lang-javascript">function styleTable(root) {
    if (root.tag == &quot;table&quot;) {
        root.attrs.class = &quot;table table-stripe&quot;;
    }
    return root;
};
</code></pre>
<p>This is the same function we used earlier, but this one can receive any template and only modifies it if the root element in the template is a table.</p>
<p><em>Recursive</em> pattern matching is achieved by creating a function that recursively calls itself to drill down a template tree, and then run some arbitrary computation if a virtual element matches some criteria. The beauty of this technique is that it makes a transformer function agnostic about the structure of the template: all that matters is that an element matches some criteria in order for it to be transformed.</p>
<p>Here&#39;s a contrived example:</p>
<pre><code class="lang-javascript">function highlightNegatives(root, parent) {
    if (!root) return root;
    else if (root instanceof Array) {
        for (var i = 0; i &lt; root.length; i++) {
            highlightNegatives(root[i], parent);
        }
    }
    else if (root.children) {
        highlightNegatives(root.children, root);
    }
    else if (typeof child == &quot;string&quot; &amp;&amp; child.indexOf(&quot;($&quot;) === 0) {
        parent.attrs.class = &quot;text-danger&quot;;
    }
    return root;
};

highlightNegatives(styleTable(table(ctrl)));
</code></pre>
<p>This function recursively drills down a template until it find a string that starts with a bracket and a dollar sign (i.e. a negative number, in financial notation). If it finds any, it adds the Bootstrap class <code>text-danger</code> to the parent DOM element. Given a table like the one from the example earlier, this function makes the text of negative numbers turn red.</p>
<p>Notice that this function works with tables with <code>thead</code>, multiple <code>tbody</code>, nested tables and just about anything else we can throw at it.</p>
<p>Be aware, however, that the recursive pattern matching technique we saw above isn&#39;t exactly cheap: it scans every element in a tree, so it&#39;s an O(n) operation. Fortunately, if a transformer function becomes a bottleneck, we can optimize it to run in O(1) by rewriting it as a Sweet.js macro.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Transformer functions are a powerful way of achieving the elusive separation of concerns between content and presentation. With them, we can write the simplest possible HTML structures to maximize readability and reusability, and then inject styles and even extra markup to support styling, after the fact.</p>
<p>As the saying goes, &quot;with great power comes great responsibility&quot;: don&#39;t abuse transformer functions to such an extent that prevents others from understanding what is happening. Transformer functions <em>can</em> be written in declarative style for a narrow number of transformation types, but as you saw above, recursive and procedural code are the most straightforward way to express data mutations. However, that type of code is typically harder to debug (especially for non-trivial transformations), so make sure you use all the tools at your disposal (comments, documentation, unit testing, etc) to make the life of your future maintainer self easier.</p>

			]]></description>
		</item>
		<item>
			<title>JSON all the things</title>
			<link>http://lhorie.github.io/mithril-blog/json-all-the-things.html</link>
			<description><![CDATA[
<h2 id="json-all-the-things">JSON all the things</h2>
<p><em>June 22, 2014</em></p>
<p>In <a href="the-uniform-access-principle.html">an earlier article</a>, we saw how we can use getter/setter functions to achieve the <a href="http://en.wikipedia.org/wiki/Uniform_access_principle">Uniform Access Principle</a>, and have data from our web services automatically map to our model entity classes.</p>
<p>This article will show you how to go the other way around: posting instances of our model classes <em>into</em> a JSON-based web service.</p>
<p>Consider this very simple class:</p>
<pre><code class="lang-javascript">function User(options) {
    this.name = m.prop(options.name);
};

var john = new User({name: &quot;John Doe&quot;});
console.log(john.name()); //logs &quot;John Doe&quot;
</code></pre>
<p>Normally, if we need to post data to a web service, frameworks will take care of running <code>JSON.stringify</code> on the Javascript object that we pass to an AJAX call. A clever reader might point out that classes w/ getter/setter methods are therefore inherently hard to serialize: After all, a getter/setter function is, well, a function, and functions cannot be serialized into JSON strings.</p>
<h3 id="or-can-they-">Or can they?</h3>
<p>If you try running the code below, it actually does what we want!</p>
<pre><code class="lang-javascript">console.log(JSON.stringify(john));
//logs &#39;{&quot;name&quot;: &quot;John Doe&quot;}&#39;
</code></pre>
<p>As it turns out, the Javascript JSON API has an extremely handy hook that is not very well known: Anything that has a <code>toJSON</code> method attached will have that method called internally by <code>JSON.stringify</code>. The example below shows how we can make a function JSON-serializable:</p>
<pre><code class="lang-javascript">var greeter = function() {
    return &quot;hello&quot;;
}
greeter.toJSON = greeter;

console.log(JSON.stringify(greeter));
//logs &quot;hello&quot;
</code></pre>
<p>Mithril&#39;s <code>m.prop</code> automatically hooks up this feature for its getters/setters, so we can easily convert POJO-based classes into UAP-enabled ones without surprises. </p>
<p>In other words, if you have a class defined this way:</p>
<pre><code class="lang-javascript">//class definition
function User(options) {
    this.name = options.name;
};

//using the class
m.request({method: &quot;POST&quot;, url: &quot;/api/users&quot;, data: new User({name: &quot;John Doe&quot;})});
</code></pre>
<p>You can simply change the class implementation to use a getter/setter:</p>
<pre><code class="lang-javascript">//class definition
function User(options) {
    this.name = m.prop(options.name);
};

//using the class
m.request({method: &quot;POST&quot;, url: &quot;/api/users&quot;, data: new User({name: &quot;John Doe&quot;})});
</code></pre>
<p>And there&#39;s no need to make any changes in the <code>m.request</code> call. It just works.</p>
<h3 id="advanced-serialization">Advanced serialization</h3>
<p>Recall that one of the reasons we&#39;re using <code>m.prop</code> getter/setter methods is so that we can eventually <em>replace</em> <code>m.prop</code> with a custom computation if ever needed.</p>
<p>The Uniform Access Principle is great at hiding the implementation details of the getter/setter, but it&#39;s a double-edged sword: it also hides the complexity of the computation. <code>m.prop</code> can always auto-serialize its value because it doesn&#39;t incur any computational cost (since it&#39;s simply storing and retriving a value from a variable internally). But as soon as you need to start doing custom computations, you need to also have control over its serialization options.</p>
<p>Let&#39;s suppose that our <code>User</code> class now needs to work with a web service that works with this data structure:</p>
<pre><code class="lang-javascript">{&quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Doe&quot;}
</code></pre>
<p>A re-implementation of the class might look like this:</p>
<pre><code class="lang-javascript">function User(options) {
    this.firstName = m.prop(options.firstName);
    this.lastName = m.prop(options.lastName);

    this.name = function() {
        return this.firstName() + this.lastName();
    };
}
</code></pre>
<p>Our application might still be using the <code>name</code> method as a convenience method, but because of the schema change that propagated from the server, we&#39;d definitely not want to serialize <code>name</code> into a JSON string. We want to post only <code>firstName</code> and <code>lastName</code>. And indeed, stringifying an instance of this new class yields the same data structure that we used to construct it:</p>
<pre><code class="lang-javascript">var john = new User({firstName: &quot;John&quot;, lastName: &quot;Doe&quot;});

console.log(JSON.stringify(john));
//logs &#39;{&quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Doe&quot;}&#39;
</code></pre>
<p>So, as you can see, classes that mix <code>m.prop</code> getter-setters with custom computed properties can be used both to convert web service data into javascript class instances and to convert these instances back to data that the web services can consume.</p>
<p>As an aside, if we did want to serialize a computed property for whatever reason, it&#39;s possible to do so by just using the JSON API hook we saw earlier:</p>
<pre><code class="lang-javascript">function User(options) {
    this.firstName = m.prop(options.firstName);
    this.lastName = m.prop(options.lastName);

    this.name = function() {
        return this.firstName() + this.lastName()
    };

    //make `name` serializable
    this.name.toJSON = this.name;
};

var john = new User({firstName: &quot;John&quot;, lastName: &quot;Doe&quot;});
console.log(JSON.stringify(john));
//logs &#39;{&quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Doe&quot;, &quot;name&quot;: &quot;John Doe&quot;}&#39;
</code></pre>
<h3 id="last-thoughts">Last thoughts</h3>
<p>The JSON API&#39;s ability to process anything that has a <code>toJSON</code> method is very handy in supporting holistic UAP-enabled classes.</p>
<p>If you are familiar with statically typed OOP languages like Java or C#, you&#39;ll probably notice that the pattern of adding specific methods to make an object consumable by other APIs is essentially the same thing as implementing Interfaces (but without verbosity). Here&#39;s how you would express the JSON-serializable interface in Typescript:</p>
<pre><code>interface JSONSerializable {
    toJSON(data:any): any
}
</code></pre><p>Javascript itself, however, is dynamically typed, so this interface does not necessarily exist as code anywhere - it literally takes <em>zero lines-of-code</em> to write its signature, simply because the runtime won&#39;t complain if it&#39;s not defined. But it&#39;s important to understand what it is conceptually, especially if you start using this technique to create your own interface consumers, so that you can then document your features effectively, instead of having them look like undocumented voodoo magic.</p>

			]]></description>
		</item>
		<item>
			<title>The uniform access principle</title>
			<link>http://lhorie.github.io/mithril-blog/the-uniform-access-principle.html</link>
			<description><![CDATA[
<h2 id="the-uniform-access-principle">The Uniform Access Principle</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Uniform_access_principle">Uniform Access Principle</a> (UAP) is a concept that states that &quot;all services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation&quot;.</p>
<p>What this principle is saying is that an API should not break if one of its public interfaces changes from returning a simple value to returning a value from a computation.</p>
<p>Let&#39;s see what this means in practice. Consider this class:</p>
<pre><code class="lang-javascript">function User(options) {
    this.name = options.name;
    this.age = new Date().getFullYear() - options.birthdayYear;
};

var john = new User({name: &quot;John&quot;, birthdayYear: 1980});
console.log(john.age);
</code></pre>
<p>It&#39;s pretty straightforward code: we define a user, who can have a name and age. We can set the name and a birthday year through the constructor, and then later we can modify the name and age by accessing the properties directly. But the smart reader will notice this is not very good code. In the real world, time passes, and John isn&#39;t going to be 30 years old forever.</p>
<p>We all know bugs happen and requirements change, so fixing this type of issue is a fact of life. But the real underlying problem here is that changing the implementation to be correct requires us to change the API of the User class:</p>
<pre><code class="lang-javascript">function User(options) {
    this.name = options.name;
    this.age = function(age) {
        var now = new Date().getFullYear()
        if (age) options.birthdayYear = now - age
        return now - options.birthdayYear;
    }
}

var john = new User({name: &quot;John&quot;, birthdayYear: 1980});
console.log(john.age()); //notice this is now a function call
</code></pre>
<p>That might not look like a big deal, but consider that this is a very trivial example. In a real application, the rules that govern an entity&#39;s field could change in any dimension, and the entity might be used in hundreds of different places in the codebase.</p>
<h3 id="enter-getters-setters">Enter getters/setters</h3>
<p>In enterprise ecosystems with static typing, you can find IDEs that can do automatic refactoring of code, but this type of analysis is extremely difficult to do in dynamic languages like Javascript (especially once you start considering things like <code>new Function</code> and string-based property access).</p>
<p>The next best thing is to have support for getter-setters baked right into the language. But as it turns out, getter-setters in Javascript have a long and ugly history. <a href="http://ejohn.org/blog/javascript-getters-and-setters/">Here&#39;s an article from 7 years ago</a> that claims getters/setters were <em>starting</em> to become noteworthy. Today, that syntax is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineGetter">non-standard and not recommended for use in production</a>. Instead we have <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>, which doesn&#39;t work corrrectly in IE8 and below (i.e. it&#39;s not production-ready either). In short: a decade has passed and we still don&#39;t have proper support for getters/setters!</p>
<p>Fortunately, there&#39;s another way to go about getters/setters: getter/setter methods. You might not have been aware, but you probably have used them before in Javascript:</p>
<pre><code class="lang-javascript">var value = $(&quot;input&quot;).val(); //getter

$(&quot;input&quot;).val(value); //setter
</code></pre>
<p>Mithril provides simple getter/setter methods via <code>m.prop</code> and, in addition to the regular getting and setting of values, they can also be used as a functional composition tool. Here&#39;s an example of a getter/setter function being used to implement bidirectional data binding:</p>
<pre><code class="lang-javascript">var prop = m.prop(&quot;hello&quot;);

prop(&quot;foo&quot;); //setter

var value = prop(); //getter

m(&quot;input&quot;, {oninput: m.withAttr(&quot;value&quot;, prop), value: prop()});
</code></pre>
<p>The last line passes <code>prop</code> as an argument to the higher-order function <code>m.withAttr</code>, which creates an event handler that calls <code>prop</code> as a setter. The <code>value</code> property is assigned by simply calling the getter. In a ironic way, this technique - that could be done with Javascript a decade ago - is far more powerful than if we did have getter/setter syntax baked into the language.</p>
<p>But let&#39;s go back to the original topic: getters/setters are an effective mechanism to implement the Uniform Access Principle in classes.</p>
<p>In practical terms, this means we can just implement our User class using <code>m.prop</code> in order to achieve UAP. Here&#39;s what the original broken class would look like:</p>
<pre><code class="lang-javascript">function User(options) {
    this.name = m.prop(options.name);
    this.age = m.prop(new Date().getFullYear() - options.birthdayYear);
}
var john = new User({name: &quot;John&quot;, birthdayYear: 1980});
console.log(john.age());
</code></pre>
<p>Now if we need to modify the implementation to fix it, we no longer need to break the User class&#39; API:</p>
<pre><code class="lang-javascript">function User(options) {
    this.name = m.prop(options.name);
    this.age = function(age) {
        var now = new Date().getFullYear()
        if (age) options.birthdayYear = now - age
        return now - options.birthdayYear;
    }
}
var john = new User(&quot;John&quot;, 1980);
console.log(john.age()); //same API as before
</code></pre>
<h3 id="bonus">Bonus</h3>
<p>One last thing: you might have noticed that the class creation idiom we&#39;ve been using in this article is using an <code>options</code> argument. This is the same best practice we use when authoring libraries with customization options. And this same pattern allows us to automatically integrate our class to <code>m.request</code>, so we can get UAP out of the box from our web services&#39; POJOs:</p>
<pre><code class="lang-javascript">var users = m.request({method: &quot;GET&quot;, url: &quot;/api/users/&quot;, type: User});
</code></pre>
<p>Notice that we&#39;re passing <code>User</code> as a <code>type</code> option into <code>m.request</code>. This passes the data items from the web service as an argument to the User class, so that when the AJAX response above resolves successfully, the <code>users</code> getter/setter function will contain a list of User class instances. Assuming the web service returned a list of objects with <code>name</code> and <code>birthdayYear</code> fields, we could then access the properties of the User class instances in the view using getter/setter syntax:</p>
<pre><code>users().map(function(user) {
    //notice `user` is an instance of our `User` class
    return [
        m(&quot;div&quot;, &quot;name:&quot; + user.name())
        m(&quot;div&quot;, &quot;age:&quot; + user.age())
    ];
})
</code></pre><p>And, of course, as we saw earlier, modifying the internal implementation of the User class requires no major refactoring of the rest of our code.</p>
<p>In short, by simply structuring our plain vanilla Javascript classes using best practices and using <code>m.prop</code> (or any getter/setter function), we can also get the benefits of UAP for better separation of concerns and refactorability.</p>

			]]></description>
		</item>
		<item>
			<title>Put your controllers on a diet</title>
			<link>http://lhorie.github.io/mithril-blog/put-your-controllers-on-a-diet.html</link>
			<description><![CDATA[
<h2 id="put-your-controllers-on-a-diet">Put your controllers on a diet</h2>
<p>Many developers have been conditioned by their frameworks to think that the model layer should only hold classes that represent database tables, and that controllers are the correct place to put business logic.</p>
<p>But as it turns out, in the original MVC paradigm, <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">business logic is meant to live in the model layer</a>. Controllers are meant to be merely a channel that orchestrates communication between the view and model layers.</p>
<p>Here&#39;s a contrived example to illustrate:</p>
<pre><code class="lang-javascript">//model
var form = {
    getData: function() {
        return {name: m.prop(&quot;&quot;), age: m.prop(&quot;&quot;), saved: m.prop(false), error: m.prop(&quot;&quot;)}
    },
    setData: function(data) {
        return m.request({method: &quot;POST&quot;, url: &quot;/user&quot;, data: {name: data.name(), age: data.age()}})
            .then(data.saved.bind(this, true), data.error)
    }
};

//controller
form.controller = function() {
    this.data = form.getData();

    this.save = function() {
        form.setData(this.data);
    }.bind(this)
};

//view
form.view = function(ctrl) {
    return m(&quot;form&quot;, [
        m(&quot;input[placeholder=name]&quot;, {oninput: m.withAttr(&quot;value&quot;, ctrl.data.name)}, ctrl.data.name()),
        m(&quot;input[placeholder=age]&quot;, {oninput: m.withAttr(&quot;value&quot;, ctrl.data.age)}, ctrl.data.age()),
        m(&quot;button&quot;, {onclick: ctrl.save}, &quot;Save&quot;),
        ctrl.saved() ? &quot;Saved!&quot; : &quot;&quot;,
        ctrl.error() || &quot;&quot; // show error if any
    ]);
};

m.module(document, form);
</code></pre>
<p>Here, the call in the last line <code>m.module(document, form)</code> in the view layer tells the controller that the view needs to be initialized. The controller then tells the model layer to make data available. Once the data is available (which is instantaneous in this case since we&#39;re pulling a blank data structure from memory), Mithril then triggers the rendering of the template.</p>
<p>In a similar fashion, clicking the button calls the <code>save</code> method in the controller, which in turn calls <code>setData</code> in the model. This time, once the AJAX request completes, the code updates the value of the <code>saved</code> flag in the model, and then Mithril triggers a redraw of the template to display the success message.</p>
<p>Note how all the data is neatly tucked in the model layer. In this example, I&#39;m purposely using a pattern that ties the model data very closely to the UI schema - what is known as a <strong>View Model</strong>. From an MVC point of view, a view model is still a part of the model layer because its primary function is to handle data - data that ties closely to the UI structure, but still data.</p>
<h3 id="the-road-to-hell">The road to hell</h3>
<p>Here&#39;s a common variation of the example above. It fundamentally misunderstands the intent of the pattern above and puts the model responsibilities directly in the controller:</p>
<pre><code class="lang-javascript">var form = {};

//controller
form.controller = function() {
    this.data = {name: m.prop(&quot;&quot;), age: m.prop(&quot;&quot;), saved: m.prop(false), error: m.prop(&quot;&quot;)}

    this.save = function() {
        m.request({method: &quot;POST&quot;, url: &quot;/user&quot;, data: {name: this.data.name(), age: this.data.age()}})
            .then(this.data.saved.bind(this, true), this.data.error)
    }.bind(this)
};

//view
form.view = function(ctrl) {
    return m(&quot;form&quot;, [
        m(&quot;input[placeholder=name]&quot;, {oninput: m.withAttr(&quot;value&quot;, ctrl.data.name)}, ctrl.data.name()),
        m(&quot;input[placeholder=age]&quot;, {oninput: m.withAttr(&quot;value&quot;, ctrl.data.age)}, ctrl.data.age()),
        m(&quot;button&quot;, {onclick: ctrl.save}, &quot;Save&quot;),
        ctrl.data.saved() ? &quot;Saved!&quot; : &quot;&quot;,
        ctrl.data.error() || &quot;&quot; // show error if any
    ]);
};
</code></pre>
<p>This pattern is common partly because some frameworks have a very liberal interpretation of MVC which encourages pretty much all logic to live in controllers. There&#39;s also a lot of confusion among developers as to what MVC actually means, and the existence of patterns like MVVM and MVP causes even more confusion.</p>
<p>The code using the pattern above is shorter, yes, but this is a misleading gain: this code is also more tightly coupled, and therefore harder to scale and maintain down the road.</p>
<h3 id="increasing-complexity">Increasing complexity</h3>
<p>Let&#39;s increase the complexity of our example a little bit to see why the shorter code is bad: let&#39;s add a bit of validation.</p>
<p>Ignoring for a moment that we&#39;d never store an &quot;age&quot; field into the database, we could still validate it to ensure it&#39;s a positive number.</p>
<p>To add validation in the original example, we change the model method code:</p>
<pre><code class="lang-javascript">setData: function(data) {
    return m.request({method: &quot;POST&quot;, url: &quot;/user&quot;, data: {name: data.name(), age: data.age()}})
        .then(data.saved.bind(this, true), data.error)
}
</code></pre>
<p>To something like this:</p>
<pre><code class="lang-javascript">setData: function(data) {
    if (parseInt(data.age()) &lt;= 0) data.error(&quot;Age must be a positive number!&quot;)
    else return m.request({method: &quot;POST&quot;, url: &quot;/user&quot;, data: {name: data.name(), age: data.age()}})
        .then(data.saved.bind(this, true), data.error)
}
</code></pre>
<p>And there&#39;s the problem with the controller taking the role of the view model. While in the first example, this <code>if</code>/<code>else</code> validation structure is neatly contained in the <code>setData</code> method, in the second example, it ends up being inline in the controller.</p>
<p>What that means is that, as the application grows, any time you need to deal with the <code>age</code> of a <code>user</code> entity, you don&#39;t have a single point of contact for validating the age - you end up copying and pasting the validation snippet everywhere (or get potentially invalid data if you forget). And when validation rules change (yes, <em>when</em>, not <em>if</em>), you end up being forced to audit a whole lot more code than if the validation code was contained within a single point of contact in the model layer.</p>
<p>A clever reader might retort that the view model in our first example is no better, because different parts of the application would likely use different view models, and the duplication of code would still happen.</p>
<p>This is only true because I wrote the code in a very specific way in order to illustrate how code can evolve over time. The separation of concerns achieved by having a view model entity has another subtle but important purpose: keeping the validation in a <code>setData</code> method that is exclusively about users means that we can be sure there aren&#39;t other implicit dependencies at play via closures and fall-through state in the controller scope. This is an important property for code to have, because it means we can refactor the model layer code more easily to separate the <em>user</em> concern away from the <em>UI view model</em> concern.</p>
<p>In a real life application, we might get a change request to add a section to the form about a completely unrelated thing, or maybe a request to redirect the user to another page automatically after saving successfully. The code to handle this orchestration might involve touching several view models and might issue commands to the framework to handle the redirects. If numerous view models - validation code and all - get mixed with orchestration code in a big monolithic controller function, they just become extra mental baggage that slows down our refactoring efforts (or prevents it altogether).</p>
<p>Having the code already semi-refactored in a view model entity, we can then apply the OOP stuff we learned in school: instead of calling a naked <code>m.request</code> for a user directly from the form view model entity (which sounds like an obviously dumb idea as soon as we say it out loud), we can create a self-contained <code>User</code> class and use it in the view model entity to manage user state and validation, without getting bogged down by the controller&#39;s redirect logic and other unrelated stuff.</p>
<p>In other words, the first example is closer to an ideal codebase than the second, and therefore takes less effort to refactor, and is less likely to end up in code rot.</p>
<h3 id="conclusion">Conclusion</h3>
<p>It&#39;s very rare that we&#39;ll write perfect code on our first try, especially with tricky business logic taking most of our mental power (and the looming deadlines filling the rest of our brains with stress), but it&#39;s very common that we&#39;ll have to maintain the resulting code through rounds and rounds of maintenance and changes. It&#39;s very important to have a solid understanding of what logic is tied closely to what data, so we can achieve DRYness and separation of concerns more effectively, rather than slicing the code in the wrong dimensions and then hitting a wall of code rot a few months down the road.</p>
<p>Moving state machines out of controllers is a good start. Acknowledging that the model can have both business data and UI state data (and that the two are separate things) is another step in the right direction.</p>
<p>However, we should always be mindful that these are techniques to achieve a goal, NOT dogmatic golden rules: blindly separating everything into small boxes doesn&#39;t automatically makes code good, and in fact can be detrimental if we separate things that are actually meant to be together. This is precisely the misunderstanding that yields well-intentioned but problematic code with self-contained model classes, and self-contained controllers holding validation code for said classes.</p>
<p>Separation of concerns isn&#39;t itself an end goal. Keeping our code refactorable as it grows in complexity is what we really want to achieve.</p>

			]]></description>
		</item>
		<item>
			<title>Saving is hard</title>
			<link>http://lhorie.github.io/mithril-blog/saving-is-hard.html</link>
			<description><![CDATA[
<h2 id="saving-is-hard">Saving is hard</h2>
<p>When we first come across the idea of RESTful web services over HTTP, the first thing we usually learn is that, instead of defining a URL like &quot;/getThings/&quot;, the <code>GET</code> method is the way to express that we want to get things from the server, e.g. (<code>GET /thing/</code>). <code>DELETE</code> deletes things, so the rest of the HTTP methods should all be more or less the same deal, right?</p>
<p>As it turns out, inserting and updating things are kind of complicated: there is the <code>POST</code> method that we&#39;ve all used for both purposes in the past, and then we discover there are also <code>PUT</code> and <code>PATCH</code>.</p>
<hr>
<h3 id="post">POST</h3>
<p>The HTTP spec is a bit of a blabbermouth. Here&#39;s what it says about <code>POST</code>:</p>
<pre><code>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line
</code></pre><p>What this means is that <code>POST</code> is meant to be used for creating entities as part of something else. Think of that something as an Array, and of <code>POST</code> as of its <code>push</code> method: when we don&#39;t know the index which we are putting our item at, we <code>push()</code> it and get the array index back that we can use to identify our item later. Same with <code>POST</code>: when we don&#39;t know the ID of the entity, we <code>POST</code> to the list so we can find out the ID from the response. Then we can <code>GET</code> the entity by ID later.</p>
<p>For example, let&#39;s say an app deals with users, which are represented by the URL <code>/users/</code>. We can <code>POST</code> a new user to this URL even if this user entity does not have an ID. The response should tell us an ID that will let us later find it, e.g. <code>GET /users/1</code></p>
<p>We are <em>not</em> supposed to send a <code>POST /users/1</code> request if we are looking to update the user whose ID is 1</p>
<pre><code class="lang-javascript">//assuming the list of users is empty
//create new user in the list of users
var newUser = {name: &quot;John&quot;, email: &quot;johndoe@example.com&quot;}
m.request({method: &quot;POST&quot;, url: &quot;/users/&quot;, data: newUser})
    .then(function(response) {
        console.log(response) // {id: 1, name: &quot;John&quot;, email: &quot;johndoe@example.com&quot;}
    })

//retrive the  user
m.request({method: &quot;GET&quot;, url: &quot;/users/1&quot;})
    .then(function(response) {
        console.log(response) // {id: 1, name: &quot;John&quot;, email: &quot;johndoe@example.com&quot;}
    })



//the following is INCORRECT usage of POST
var newUser = {id: 1, name: &quot;John&quot;, email: &quot;johndoe@example.com&quot;}
//notice ID in the URL, so this request should return an error
m.request({method: &quot;POST&quot;, url: &quot;/users/1&quot;, data: newUser})
    .then(function(response) {
        console.log(response) // this should not get called
    }, function(error) {
        console.log(error) // &quot;cannot add user as child of itself&quot;
    })
</code></pre>
<hr>
<h3 id="put">PUT</h3>
<p>Here&#39;s what the spec says about <code>PUT</code>:</p>
<pre><code>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.
</code></pre><p>This means <code>PUT</code> is meant to be used to update or insert (aka &quot;upsert&quot;) into whatever is represented by the URL. Again, using the Array analogy, <code>PUT</code> is somewhat like <code>list[i] = value</code>, where <code>i</code> is explicitly in the URL. This operation may overwrite anything that is already there, or it might add a new thing if nothing exists at that index. An important implication is that just like assigning <code>list[i] = value</code> multiple times always results in the same thing, <code>PUT</code> is also not supposed to have side effects.</p>
<p>For example, we can send a <code>PUT /users/1</code> request to add or update a user whose ID is 1.</p>
<pre><code class="lang-javascript">//assuming the same list of users as before
//create new user in the list of users
var newUser = {id: 2, name: &quot;Mary&quot;, email: &quot;marydoe@example.com&quot;}
m.request({method: &quot;PUT&quot;, url: &quot;/users/2&quot;, data: newUser})
    .then(function(response) {
        console.log(response) // {id: 2, name: &quot;Mary&quot;, email: &quot;marydoe@example.com&quot;}
    })

//update the user
m.request({method: &quot;PUT&quot;, url: &quot;/users/2&quot;, data: newUser})
    .then(function(response) {
        console.log(response) // {id: 2, name: &quot;Mary&quot;, email: &quot;marydoe@example.com&quot;}
        //notice no data has changed
    })

//the following is INCORRECT usage of PUT
var newUser = {id: 2, name: &quot;Mary&quot;, email: &quot;marydoe@example.com&quot;}
//notice URL has no ID, so this request should return an error
m.request({method: &quot;PUT&quot;, url: &quot;/users/&quot;, data: newUser})
    .then(function(response) {
        console.log(response) // this should not get called
    }, function(error) {
        console.log(error) // &quot;cannot replace list of users&quot;
    })
</code></pre>
<hr>
<h3 id="patch">PATCH</h3>
<pre><code>The PATCH method requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI. The set of changes is represented in a format called a &quot;patch document&quot; identified by a media type. If the Request-URI does not point to an existing resource, the server MAY create a new resource, depending on the patch document type (whether it can logically modify a null resource) and permissions, etc.
</code></pre><p><code>PATCH</code> is an interesting method: it is meant to be used as a mechanism to batch operations. In our Array analogy, it&#39;s similar (but not analogous) to <code>splice</code>. Instead of accepting just data, it accepts a document that contains instructions on what to do with the attached data. It can add, delete and modify items to the list. The spec doesn&#39;t require it to be idempotent (i.e. it can perform irreversible actions, such as deleting items, sending out emails or making a purchase), but it requires that all the operations requested must be done atomically, i.e. either all of them succeed or the entire batch must be rolled back and rejected, no partial updates allowed.</p>
<pre><code class="lang-javascript">var operations = {
    add: [
        {name: &quot;Jane&quot;, email: &quot;janedoe@example.com&quot;}
    ],
    upsert: [
        {id: 2, name: &quot;Mary&quot;, email: &quot;marydoe@example.com&quot;}
    ],
    delete: [
        {id: 1}
    ]
}
m.request({method: &quot;PATCH&quot;, url: &quot;/users/&quot;, data: operations})
    .then(function(response) {
        console.log(response)
        /* notice &quot;John&quot; was deleted
        [
            {id: 2, name: &quot;Mary&quot;, email: &quot;marydoe@example.com&quot;},
            {id: 3, name: &quot;Jane&quot;, email: &quot;janedoe@example.com&quot;}
        ]
        */
    })
</code></pre>
<p>Notice that if we run this example request a second time, it would not add another user called Jane (and it would not attempt to update Mary), because there&#39;s no user with ID = 1 to delete, and therefore the entire set of changes is required to be rejected.</p>
<hr>
<h3 id="why-not-just-use-post-everywhere-">Why not just use POST everywhere?</h3>
<p>One might wonder what is the point of having so many different ways of saving data. What&#39;s wrong with just using POST for everything like we&#39;ve always been doing?</p>
<p>When your application&#39;s client side code is the only consumer of your web services, you can get away with just doing whatever you want because reinventing the wheel as you go has a lower cognitive load than consulting the HTTP specs all the time. However, when we&#39;re talking about public web services that are usable by other people, it&#39;s important that they can discover what is doable and how. If they need to consult your documentation (assuming you have one!) to figure out whether they should send a request to <code>/getusers/</code> or <code>/users/get</code> or <code>/search?type=user</code>, it causes the same type of cognitive load as it would take you to learn the HTTP spec. Obviously in that situation it&#39;s better for everyone to learn the HTTP spec once, than everyone having to learn the arbitrary vocabularies of every possible web service that they might need.</p>
<p>More importantly, by learning the HTTP spec, you can become aware of things that your perhaps simplistic application did not think about, and you can fix them to make your code better. One example that is frequently neglected: does your web service have support for saving multiple items at once? (e.g. how would you do the checkboxes in the gmail list?)</p>
<p>Another reason to understand the spec is to become aware that HTTP verbs don&#39;t translate perfectly into the naive idea of CRUD (create/read/update/delete). With this knowledge, you can understand that autogenerated model layers might limit what you can do by attempting to map the business logic to an over-simplistic view of the world. Hopefully, you&#39;ll also start to understand that a model layer that exposes the transport details to controllers (by merely giving you a class with renamed methods like <code>.update()</code> for <code>POST</code>) isn&#39;t all that helpful to you, especially if said class methods do too much magic and it&#39;s hard to refactor away from them.</p>
<p>Ultimately, you&#39;ll want to ensure your model layer API expresses your business needs first and foremost, as opposed to trying to conform to some arbitrary programming design pattern for its own sake. The model layer is an abstraction layer: you want its API to be more expressive than just wrapping CRUD with different names. You want to be able to do things that don&#39;t fit a simplified CRUD mold, and you don&#39;t want to reinvent the wheel and relearn all the lessons that the HTTP spec already ironed out years ago. Making that leap takes a little more brain power because it actually forces you to think about good API design, but in the end the effort pays off: you get better separation of concerns and modularity, which translate to shorter, easier to maintain code.</p>

			]]></description>
		</item>
		<item>
			<title>Inteview with James Long</title>
			<link>http://lhorie.github.io/mithril-blog/interview-with-james-long.html</link>
			<description><![CDATA[
<h2 id="interview-with-james-long">Interview with James Long</h2>
<p>This week I&#39;m trying something different. I&#39;ve been in touch with <a href="https://twitter.com/getgini">Hrishi Mittal</a>, a marketing guy, and he suggested doing interviews with people doing awesome things (particularly with frontend technologies). So we thought a follow-up on the <a href="http://lhorie.github.io/mithril-blog/an-exercise-in-awesomeness.html">article about reducing UI complexity</a> would be interesting.</p>
<p>Anyways, without further ado.</p>
<p>James Long is a web developer at Mozilla in the Firefox Developer Tools team. His projects include a fork of LLJS that compiles to asm.js, things built on nunjucks (a templating engine for Javascript) and even an iOS game involving farm animals (<a href="https://github.com/jlongster">https://github.com/jlongster</a> ). He blogs at <a href="http://jlongster.com">http://jlongster.com</a> and tweets at <a href="https://twitter.com/jlongster">https://twitter.com/jlongster</a>.</p>
<p>In this interview, I talk to James about his work at Mozilla, his personal projects and recent experimentation with MVC frameworks.</p>
<p><strong>Tell me about yourself and your work at Mozilla</strong></p>
<p>I&#39;m 29 years old and I work remotely from Virginia for Mozilla. I like
to keep track of what&#39;s being researched in the academic world (and
also communities like Clojure) and help bring those ideas to
JavaScript. My day job for Mozilla is working on the Firefox Developer
Tools, particularly the debugger. I&#39;m somewhat new to the team and I
love helping developers debug their code.</p>
<p><strong>Could you please tell me about the motivation of the &quot;Removing User Interface Complexity&quot; article?</strong></p>
<p>I&#39;ve been eagerly watching what&#39;s happening with UIs on the web world
for a while. Web Components has always been confusing to me because
the practical examples everybody shows don&#39;t actually deliver what
they promise. Last week I tried to use a Web Component with Ember, but
there&#39;s no way to bind an element&#39;s event to your controller method in
a template. This is Web Components fault; they don&#39;t provide the right
API to make this work yet. Google calls Polymer a library, but to me
it feels like an awkward framework, and it doesn&#39;t show off the actual
interesting parts of Web Components: hooking them into different
existing frameworks.</p>
<p>Meanwhile, Facebook released React. I didn&#39;t understand it at first,
but after reading David Nolen&#39;s blog post [1] I instantly got it.
After using it for a while, I really fell in love with it. It truly is
a library, letting you use any data structure you want, and it only
cares about rendering and separating out your UI into components.</p>
<p>My blog post initially was a rant about Web Components and how
confusing the messaging (particularly Google&#39;s) is. It didn&#39;t feel
productive though, so I decided to focus on React and explain what I
thought was the right way to do UIs in modern apps, and compare it to
Web Components here and there. I wanted to push Web Components to
focus on low-level plumbing for sharing components, not a framework.</p>
<p><strong>You do some pretty cool interactive stuff in that article. Did you start out thinking you&#39;d do all that or did you get the idea while writing it? How long did it take you to write it?</strong></p>
<p>When I decided to focus on React, I definitely wanted to do something
cool and interactive. I knew it needed that to fully demonstrate the
concepts. Writing demos also forced me to stay grounded and not go too
abstract. I&#39;ve had the idea for that specific layout before when
writing other posts, but this is the first time trying it. It took
about 3 weeks off and on to write the whole post, including the
interactive layout.</p>
<p><strong>How important do you think client-side MVC frameworks are for mobile?</strong></p>
<p>They might even be more important for mobile than desktop. Content in
mobile often takes the shape of an &quot;app&quot;, which has very clear needs
for something like MVC that handles separate views, how they interact,
and binding data to the UI. The really good modern libraries &amp;
frameworks also help keep your app performant by reducing DOM changes.</p>
<p><strong>You&#39;ve built iOS games too, one of them called Farmageddon which you recently open sourced. How does programming for iOS compare to web programming, personally for you?</strong></p>
<p>My iOS experience is dated by about 4 years, so a lot has probably
changed. In general, iOS provides a really good, solid set of
libraries for making powerful apps, and the web is still catching up
with these APIs. However, I&#39;d take making UIs on the web over iOS any
day, where you have to manually manage lots of UIViews and things like
that. Although HTML/CSS/JS has its quirks, it really is flexible for
creating UIs.</p>
<p><strong>What developer tools do you use that you couldn&#39;t live without?</strong></p>
<p>Honestly, I don&#39;t know what I&#39;d do without git and ssh. ssh is my
network plumbing, and git is my time traveling device. I know that&#39;s
low-level, but it&#39;s the first thing that came to mind. Otherwise,
Emacs is required for writing code and, of course, Firefox Developer
Tools for debugging it.</p>
<p><strong>Can you name some programmers who inspire you?</strong></p>
<p>I&#39;m an old Lisp/Schemer, so many of them come from that world. Many of
the clojurists inspire me: Rich Hickey, David Nolen, and others.
Brendan Eich, Dave Herman, Andy Wingo. All of them have had some
involvement with Scheme. I guess you could say I&#39;m inspired by the
whole Lisp/Scheme world, haha.</p>
<p>[1] <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/">http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/</a></p>

			]]></description>
		</item>
		<item>
			<title>Piggybacking requests in a widgety world</title>
			<link>http://lhorie.github.io/mithril-blog/piggybacking-requests-in-a-widgety-world.html</link>
			<description><![CDATA[
<h2 id="piggybacking-requests-in-a-widgety-world">Piggybacking requests in a widgety world</h2>
<p><em>May 18, 2014</em></p>
<p>A while back I was building a dashboard tool to display various metrics about a given person. This dashboard had a bunch of widgets, which could be toggled on or off depending on user&#39;s preferences. Some widgets are also used elsewhere in the application, so, of course, each widget needed to be self contained.</p>
<p>One recurring pattern was that I needed to display some user information in each widget (for example, the user&#39;s name).</p>
<p>Now, if the name was the only piece of data that we shared between widgets, we could consider doing a URL hack:</p>
<pre><code>http://example.com/dashboard/John_Doe
</code></pre><p>Of course, this doesn&#39;t really work once you need more pieces of information (let&#39;s say the user&#39;s email), and this approach also carries maintenance liabilities: what if the user got married and changed their name? That would break our URL.</p>
<p>So, since we were using a RESTful web service architecture, the responsible thing to do was to have a <code>users</code> web service, and have the widgets send requests to it.</p>
<p>For my case, the web service that was getting called repeatedly was one to return a single user, but for the sake of making the point of this discussion clearer, I&#39;m going to pretend that our widgets dealt with a small lists of users.</p>
<p>If you had to implement a client-side model layer to support this architecture, you&#39;d probably create some sort of CRUD class: maybe have a <code>list</code> method that fetches a list of users, right?</p>
<pre><code class="lang-javascript">//our model entity
var User = {
    list: function() {
        return m.request({method: &quot;GET&quot;, url: &quot;/api/users&quot;})
    }
};

//a module that uses our model entity
var widget1 = {};
widget1.controller = function() {
    this.users = User.list()
};
</code></pre>
<p>But right away, there&#39;s a problem: if more than one widget exists in the page at the same time, and each of those widgets needs user information, then each widget needs to individually call the web service, causing the application to send multiple identical requests to the server! (Remember, that some of these widgets are used elsewhere, so we can&#39;t move this controller logic &quot;up a level&quot;)</p>
<p>Here&#39;s a snippet of <a href="http://lhorie.github.io/mithril">Mithril</a> code to illustrate:</p>
<pre><code class="lang-javascript">var hiredThisYear = function() {/*filter by hire date*/};
var inJohnDoeTeam = function() {/* filter by team*/};

var widget1 = {};
widget1.controller = function() {
    this.users = User.list()
        .then(inJohnDoeTeam);
};

var widget2 = {};
widget2.controller = function() {
    this.users = User.list()
        .then(hiredThisYear);
};

new widget1.controller();
new widget2.controller();
</code></pre>
<p>Notice <code>widget1</code> is trying to compute a list of users in John Doe&#39;s team, and <code>widget2</code> is trying to compute a list of users who were hired this year. Both make identical AJAX requests to <code>/api/users</code>. What we really want is to send a request only once.</p>
<p>This is where <strong>separation of concerns</strong> comes in: the reason why the MVC pattern has a model layer instead of just letting us make naked AJAX requests straight from controllers is precisely so we can abstract away the implementation details regarding how data is handled.</p>
<p>In our case, we want to ensure that requests aren&#39;t duplicated, so all we need to do is change the implementation of our model entity to make duplicate requests piggyback off the first pending request:</p>
<pre><code class="lang-javascript">var cache = {};
var User = {
    list: function() {
        if (!cache[&quot;User.list&quot;]) {
            cache[&quot;User.list&quot;] = m.request({method: &quot;GET&quot;, url: &quot;/api/users&quot;})
                .then(function(value) {
                    delete cache[&quot;User.list&quot;];
                    return value;
                });
        }
        return cache[&quot;User.list&quot;];
    }
};
</code></pre>
<p>This way, when two or more calls to <code>User.list</code> happen at the same time, only the first one sends off a request. All the calls then return the same promise. After the promise resolves, we clear the cache via the <code>then</code> callback so we can request new fresh data at a later time.</p>
<pre><code class="lang-javascript">var widget1 = {};
widget1.controller = function() {
    this.users = User.list()
        .then(inJohnDoeTeam);
};

var widget2 = {};
widget1.controller = function() {
    this.users = User.list()
        .then(hiredThisYear);
};

new widget1.controller();
new widget2.controller();
</code></pre>
<p>As you can see above, the controller layer code looks exactly like it did before, but now instantiating the two widgets at the same time only sends one request to the server.</p>
<p>With some small changes, this technique can also be used for parameterized requests:</p>
<pre><code class="lang-javascript">var cache = {};
var User = {
    list: function(data) {
        var key = &quot;User.list&quot; + JSON.stringify(data)
        if (!cache[key]) {
            cache[key] = m.request({method: &quot;GET&quot;, url: &quot;/api/users&quot;, data: data})
                .then(function(value) {
                    delete cache[key];
                    return value;
                });
        }
        return cache[key];
    }
};
</code></pre>
<p>One neat thing about promises is that calling <code>then</code> multiple times from the same promise (which is what we&#39;re doing now) simply returns new promises for each call. Every one of those returned promises resolve to values that are independent of what&#39;s happening in sibling computation chains, so <code>then(inJohnDoeTeam)</code> is not affected by <code>then(hiredThisYear)</code> and therefore, when the AJAX request completes, the list of users for <code>widget1</code> is only filtered to users in John&#39;s team, and the list in <code>widget2</code> is only filtered by users hired this year, as expected.</p>
<p>In other words, the controller code continues to work correctly <em>without changes</em>.</p>
<p>I can&#39;t stress enough how important this is. Typically, you only start noticing (or financially caring about) performance problems when an app is already at a stage where there&#39;s a lot of code written. Being able to conceptualize a performance optimization like this at the design pattern level, and being able to implement it with minimal disruption to a large production application is a great example of well written code shining.</p>
<p>If you didn&#39;t get the point of MVC before, or if you think it doesn&#39;t bring any benefits, I would urge you to take some time to challenge yourself and try to understand the purpose behind the MVC design pattern. Your future self might thank you later.</p>

			]]></description>
		</item>
		<item>
			<title>An exercise in awesomeness</title>
			<link>http://lhorie.github.io/mithril-blog/an-exercise-in-awesomeness.html</link>
			<description><![CDATA[
<h2 id="an-exercise-in-awesomeness">An exercise in awesomeness</h2>
<p>James Long wrote a <a href="http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome">pretty nice article</a> about what makes a virtul-DOM based framework like React awesome.</p>
<p>Since Mithril uses the same templating mechanism, I thought it would be a good exercise to re-implement some of the more interesting examples with Mithril to see how they compare.</p>
<p>James used a made-on-the-spot 250-line toy library called &quot;Bloop&quot; to illustrate how React works. Mithril in its entirety - including the router and promise systems - is actually not a whole lot bigger (~500 lines) and does virtual DOM diffing like React (and it takes care of figuring out when to redraw, as opposed to spamming on requestAnimationFrame)</p>
<h3 id="tabbed-ui">Tabbed UI</h3>
<p>This example aimed to demonstrate the idea of storing data in a centralized location. I&#39;ve actually talked about this idea - a pattern that is known as view models in some circles - in the <a href="https://groups.google.com/d/msg/mithriljs/WOvJARwmOYA/ovA_HVTawnQJ">mailing list</a>. It&#39;s a great way to harmonize application state back into the familiar MVC design pattern. <a href="http://jsfiddle.net/kHaRa/1/">You can see the port of the example in action here</a></p>
<p>Note we are using the same concepts of passing data down the component tree via <em>props</em> (which are really just data objects being passed as function parameters), and passing data up via events (i.e. we pass down event handler references as <em>props</em> and bind the handlers locally in the appropriate component via partial application)</p>
<p>You can find James&#39; code <a href="https://gist.github.com/jlongster/3f32b2c7dce588f24c92">here</a> for comparison. A few things are slightly different: </p>
<ul>
<li><p>Instead of <code>if</code> statements in the <code>app</code> template, we&#39;re using a variation of <code>app.choose</code>, which I described in <a href="getting-over-a-fear-of-turing-complete-templates.html">this article</a>. </p>
</li>
<li><p>Instead of defining <code>randomizeColor</code> and <code>reset</code> as local instance methods in the <code>Settings</code> component, we&#39;re defining these methods in the model layer (i.e. we&#39;re using a more classic MVC style, which allows us to centralize and reuse logic).</p>
</li>
<li><p>I put the textarea with the JSON data in the about tab. It updates the data when you change its value just like the one inlined in the article.</p>
</li>
<li><p>We don&#39;t actually need full blown components in Mithril: since the Bloop components are stateless, templates are enough to modularize our code in the same way as in James&#39; article.</p>
</li>
</ul>
<p>Because data is centralized and the code structure is largely the same, it&#39;s possible to do undos in the same manner that was outlined in the article. The code for that example is pretty big and I don&#39;t have the time to port it over, so I&#39;ll leave it as an exercise to the reader to try to implement it Mithril. If anything, that&#39;s a good exercise to solidify an understanding of the data flow concepts from the tabs example.</p>
<h3 id="occlusion-culling">Occlusion culling</h3>
<p>This example shows how we can implement efficient templates that render only what is visible on screen. <a href="http://jsfiddle.net/7JNUy/1/">See it in action here.</a></p>
<p>I think the article didn&#39;t do this technique enough justice in terms of highlighting real world applications, but this is a really powerful technique that is relevant for things like infinite scrolling, deferring rendering of below-the-fold content to help breaking the <a href="http://alistapart.com/blog/post/breaking-the-1000ms-time-to-glass-mobile-barrier">mobile 1000ms barrier</a> and making parallax sites snappy.</p>
<p>The Mithril code structure is largely the same, but without spamming on requestAnimationFrame. Instead we request redraws only the scroll event, and Mithril internally throttles these calls. One philosophical difference is that I place code related to <code>window.onscroll</code> / <code>window.innerHeight</code> in the model layer. This may seem unintuitive, but remember that <code>innerHeight</code> is being used as a <em>data source</em> that is updated asynchronously by <code>window.onscroll</code>.</p>
<h3 id="conclusions">Conclusions</h3>
<p>As the examples above show, it&#39;s relatively straightforward to use the componentization / data flow model that React employs, and we can employ all of the same techniques and insights in Mithril.</p>
<p>A recurring difference in philosophy is that React is very component-centric and OOP-driven, whereas Mithril code relies more on design pattern, with decoupled helpers (a style that is most commonly seen in the Lisp world). Personally, I believe the OOP approach can be detrimental sometimes, e.g. <code>randomizeColor</code> is more about the data than the widget that calls it, so tying it to the component instance makes it less reusable. Of course, both React and Mithril workflows can be adapted to look more like the other, so this is mostly just a question of expected defaults.</p>
<p>Some commenters on HN mentioned that React also lacks a canonical way of structuring non-view-related aspects (something that I believe Flux attempts to address). On the one hand, I do agree with the sentiment (and that&#39;s why Mithril provides model-level utilities), but on the other hand, there&#39;s only so much a framework can do when it comes to the model layer. This is where the programmer is supposed to put their analytical skills to work, and I think design patterns as blueprints for the implementation are more useful tools than opinionated implementations that force one or another pattern on us (ActiveRecords comes to mind).</p>
<p>We saw an example of that with my handling of <code>window.innerHeight</code>: the code is pretty much the same - the only thing that really changed was how we interpreted it in the context of MVC. I see design patterns as a way to map a logical mental model to an implementation, and as a tool to shorten code, NOT as a mold that we must implement with code so that more code can conform to it. This is the core philosophical difference between React&#39;s OOP-style approach and Mithril&#39;s.</p>
<p>Anyways, I hope this article provided a bit of architecture design background to the conversation. Like many who read James&#39; articles, I&#39;m very excited when looking at the possibilities that virtual DOM systems enable, and I didn&#39;t want to lose the momentum on my never-ending quest for a framework that truly gets out of our way.</p>

			]]></description>
		</item>
		<item>
			<title>Getting over a fear of turing complete templates</title>
			<link>http://lhorie.github.io/mithril-blog/getting-over-a-fear-of-turing-complete-templates.html</link>
			<description><![CDATA[
<h2 id="getting-over-a-fear-of-turing-complete-templates">Getting over a fear of turing complete templates</h2>
<p>One somewhat amusing criticism against turing complete templating engines like <a href="http://lhorie.github.io/mithril">Mithril</a>&#39;s is that the ability to write procedural code enables you to write crappy code. In this post we&#39;re going to ignore the fact that you can &quot;write COBOL in any language&quot;, and that things like code reviews exist precisely to prevent this kind of problems. Rather, we&#39;re going to use another feature of turing complete programming languages - the ability to refactor and abstract away noisy code - to make our template more declarative (like HTML), and at the same time, more expressive and modular. </p>
<p>When we talk about templates, generally, people consider procedural code to be crappy, because, when we think of HTML, a template is supposed to be declarative. Here&#39;s an example of code using procedural constructs:</p>
<pre><code class="lang-javascript">var app = {}

app.view = function(ctrl) {
    var currentTab;

    switch (ctrl.tab) {
        case &quot;tab1&quot;:
            currentTab = m(&quot;.tab&quot;, &quot;tab 1 here...&quot;);
            break;
        case &quot;tab2&quot;:
            currentTab = m(&quot;.tab&quot;, &quot;tab 2 here...&quot;);
            break;
        case &quot;tab3&quot;:
            currentTab = m(&quot;.tab&quot;, &quot;tab 3 here...&quot;);
            break;
    }

    return m(&quot;.container&quot;, [
        m(&quot;ul&quot;, [
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 1&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 2&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 3&quot;)])
        ]),
        currentTab
    ]);
};
</code></pre>
<p>Let&#39;s be honest, having a <code>switch</code> statement to assign to a variable kinda sticks out like a sore thumb, doesn&#39;t it?</p>
<p>One way we can improve the code is by using <a href="http://lhorie.github.io/mithril/components.html">components</a>. This might sound like it&#39;s gonna be a lot of refactoring and a lot of code, but it&#39;s actually pretty straightforward:</p>
<p>All we need to do is pull out the subtemplates for each tab into separate functions:</p>
<pre><code class="lang-javascript">//turn each tab into a separate module
app.tab1.view = function(ctrl) {
    return m(&quot;.tab&quot;, &quot;tab 1 here...&quot;)
};

app.tab2.view = function(ctrl) {
    return m(&quot;.tab&quot;, &quot;tab 2 here...&quot;)
};

app.tab3.view = function(ctrl) {
    return m(&quot;.tab&quot;, &quot;tab 3 here...&quot;)
};
</code></pre>
<p>And then substitute them back into the main template:</p>
<pre><code class="lang-javascript">app.view = function(ctrl) {
    var currentTab;

    switch (ctrl.tab) {
        case &quot;tab1&quot;:
            currentTab = app.tab1.view(ctrl);
            break;
        case &quot;tab2&quot;:
            currentTab = app.tab2.view(ctrl);
            break;
        case &quot;tab3&quot;:
            currentTab = app.tab3.view(ctrl);
            break;
    }

    return m(&quot;.container&quot;, [
        m(&quot;ul&quot;, [
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 1&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 2&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 3&quot;)])
        ]),
        currentTab
    ]);
};
</code></pre>
<p>While we&#39;re at it, it&#39;s also a good idea to split the logic from our initial module&#39;s controller into the respective tab controllers:</p>
<pre><code class="lang-javascript">app.controller = function() {
    //the initial tab
    this.tab = &quot;tab1&quot;;

    //instantiate controllers for tabs
    //the logic for each tab should be in the respective controller
    this.tab1 = new app.tab1.controller(this);
    this.tab2 = new app.tab2.controller(this);
    this.tab3 = new app.tab3.controller(this);
};

//...
//notice we&#39;re passing the respective tab controllers here
switch (ctrl.tab) {
    case &quot;tab1&quot;:
        currentTab = app.tab1.view(ctrl.tab1);
        break;
    case &quot;tab2&quot;:
        currentTab = app.tab2.view(ctrl.tab2);
        break;
    case &quot;tab3&quot;:
        currentTab = app.tab3.view(ctrl.tab2);
        break;
}
//...
</code></pre>
<p>Doing this makes dependencies between the main module and each tab explicit. It also means we can then <a href="better-templates-with-fp.html">reuse the modules for the tabs elsewhere</a>. If, in your not-so-trivial app, you find that doing this exercise is a pain, then you just experienced the problem with what are known as &quot;god functions&quot;. God functions are hard to maintain because the implicitness provided by closures makes it hard to reason about the impact of changes as they cascade down through various unrelated parts of the app. It&#39;s usually a good idea to refactor big functions early, before things grow too big and changing things becomes too cost-prohibitive.</p>
<p>As a side note, I omitted the definitions of each module earlier, but what they are supposed to look like should hopefully be obvious (or at least easy to figure out). As an example, here&#39;s the skeleton of the <code>app.tab1</code> module, of which <code>app.tab1.view</code> is a part of:</p>
<pre><code class="lang-javascript">var app.tab1 = {}
app.tab1.controller = function() { /*...*/ }
app.tab1.view = function(ctrl) {
    return m(&quot;.tab&quot;, &quot;tab 1 here...&quot;)
}
</code></pre>
<hr>
<p>We can now refactor away our switch statement. The problem with <code>switch</code> is that it&#39;s a statement, i.e. it cannot be nested inside expressions, which is what our templates are made of. We can create a <code>switch</code>-like expression instead using a little trick from the world of Python: <strong>dictionary switches</strong></p>
<pre><code class="lang-javascript">var subject = &quot;John&quot;;

var choice = {
    &quot;John&quot;: &quot;lemonade&quot;,
    &quot;Bob&quot;: &quot;orange juice&quot;,
    &quot;Mary&quot;: &quot;tea&quot;,
}[subject];

//choice is &quot;lemonade&quot;
</code></pre>
<p>This is just a regular Javascript object, with the twist that we immediately access one of its properties to get a value that corresponds to the key we accessed.</p>
<p>We can use this technique to create a tiny helper function:</p>
<pre><code class="lang-javascript">//helper function
app.choose = function(key, options) {
    var option = options[key];
    return options[0](option[1]);
};
</code></pre>
<p>And we can then use this helper function to replace the <code>switch</code> statement:</p>
<pre><code class="lang-javascript">app.view = function(ctrl) {
    var currentTab = app.choose(ctrl.tab, {
        &quot;tab1&quot;: [app.tab1.view, ctrl.tab1],
        &quot;tab2&quot;: [app.tab2.view, ctrl.tab2],
        &quot;tab3&quot;: [app.tab3.view, ctrl.tab3]
    })

    return m(&quot;.container&quot;, [
        m(&quot;ul&quot;, [
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 1&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 2&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 3&quot;)])
        ]),
        currentTab
    ]);
};
</code></pre>
<p>Or even better, we can drop the variable assignment altogether:</p>
<pre><code class="lang-javascript">app.view = function(ctrl) {
    return m(&quot;.container&quot;, [
        m(&quot;ul&quot;, [
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 1&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 2&quot;)]),
            m(&quot;li&quot;, [m(&quot;a&quot;, &quot;Tab 3&quot;)])
        ]),
        //here we use our helper
        app.choose(ctrl.tab, {
            &quot;tab1&quot;: [app.tab1.view, ctrl.tab1],
            &quot;tab2&quot;: [app.tab2.view, ctrl.tab2],
            &quot;tab3&quot;: [app.tab3.view, ctrl.tab3]
        })
    ]);
};
</code></pre>
<p>Doesn&#39;t that look cleaner? Let&#39;s break things down a little bit.</p>
<p><code>app.choose</code> accepts 2 parameters: a key and a dictionary. In the code above, the dictionary switch has three options, <code>tab1</code>, <code>tab2</code> and <code>tab3</code>. We pick one of those via the square bracket notation and <code>ctrl.tab</code> (which is <code>tab1</code> on initial load, if you recall the controller code ealier).</p>
<p>The value that corresponds to <code>tab1</code> is <code>[app.tab1.view, ctrl.tab1]</code>. <code>app.choose</code> calls the first item in the array as a function and passes the second one as an argument. In other words, it calls <code>app.tab1.view(ctrl.tab1)</code>, thus rendering the <code>app.tab1</code> component.</p>
<p>Phew!</p>
<p>A neat thing to notice is that <code>app.choose</code> is <em>also</em> a reusable tool. We can use it to toggle other tab groups, or for that matter, page menus, accordions, or any switchable widget. Not bad for a 2-liner helper function, huh?</p>
<hr>
<h3 id="last-thoughts">Last thoughts</h3>
<p>Before we wrap up, I just wanted to mention one last thing for those who might be having trouble keeping templates declarative. These are probably a little more well known tricks to savvier Javascript developers, but I&#39;ve had quite a few people use statement-based idioms when asking me questions, and I think it&#39;s worthwhile being thorough.</p>
<p>We can get rid of other flow control statements from views, in a similar way to how we replaced <code>switch</code>:</p>
<ul>
<li><p><code>if</code> statements can be replaced with the ternary operator:</p>
<pre><code class="lang-javascript">//instead of this
var widget
if (someCondition) {
   widget = m(&quot;div&quot;, &quot;widget here&quot;)
}

m(&quot;div&quot;, [
   widget
])

//we can use this
m(&quot;div&quot;, [
   someCondition ? m(&quot;div&quot;, &quot;widget here&quot;) : &quot;&quot;
])
</code></pre>
</li>
<li><p>loops can usually be replaced with <code>Array.prototype.map()</code></p>
<pre><code class="lang-javascript">//instead of this
var items = [];
for (var i = 0; i &lt; someList.length; i++) {
   var tpl = m(&quot;div&quot;, &quot;list item &quot; + i)
   items.push(tpl);
};

m(&quot;div&quot;, items)

//we can use this
m(&quot;div&quot;, [
   someList.map(function(item, i) {
       return m(&quot;div&quot;, &quot;list item &quot; + i)
   })
])
</code></pre>
</li>
</ul>
<p>Remember we can also create other helper functions like <code>app.choose</code> above to express more intricate flow control, as we did w/ <a href="building-a-seinfeld-app.html"><code>seven</code> in the Seinfeld app</a> a few weeks ago. Don&#39;t be afraid to create new functions to pull out noise out of templates. You may have been conditioned to think of the view layer as an area of the app that should only contain declarative templates, but in reality, the view layer can house helper functions as well.</p>
<p>Good view layer code means that <em>templates</em> should be as declarative as possible, NOT that the view layer as a whole should avoid procedural logic altogether.</p>
<p>Anyways, that&#39;s all I have for today. Hopefully, this article can help making your templates cleaner.</p>

			]]></description>
		</item>
		<item>
			<title>Lessons learned from Angular</title>
			<link>http://lhorie.github.io/mithril-blog/lessons-learned-from-angular.html</link>
			<description><![CDATA[
<h2 id="lessons-learned-from-angularjs">Lessons learned from AngularJS</h2>
<p><em>May 4, 2014</em></p>
<p>Some people have asked me what are the differences between <a href="http://lhorie.github.io/mithril">Mithril</a> and <a href="http://angularjs.org">Angular</a></p>
<p>I actually <a href="http://lhorie.github.io/mithril/comparison.html">wrote about some of the high-level differences here</a>.</p>
<p>You might notice that on the Angular section, I go quite a bit more in depth than some other frameworks&#39; comparisons.</p>
<p>As it turns out, I work with Angular a lot, so a lot of design decisions in Mithril come directly from my experience with it. In this article, I&#39;ll talk about some of the rationales behind Mithril&#39;s template design.</p>
<p>Angular uses what it calls <em>directives</em> to enrich HTML with functionality. Directives are essentially a mechanism that attaches functionality to DOM elements in an unobtrusive manner. Directives can be bound to elements, attributes or class names and provide a &quot;free out-of-jail card&quot; of sorts that allows developers to break out of Angular&#39;s environment and access the DOM directly. There are <a href="http://docs.angularjs.org/api/ng/directive">dozens of directives</a> that come out of the box, and it&#39;s possible to create custom ones as well.</p>
<p>Well written directives really shine as consumable APIs: they allow developers to declaratively add rich functionality to a static HTML page: you can whip up a code editor just as easily as a native HTML textarea.</p>
<p>The main problem with directives is their sheer complexity: when writing a directive, you quick stumble across things like scope isolation and <code>$scope.$apply</code>, and the complexity only goes up when you start to look into more advanced concepts like transclusions, <code>$compile</code>, the <code>ngModelController</code>, etc. And complexity goes higher still when you need to debug &quot;$digest already in progress&quot; errors, or worse, the dependency graph of your app&#39;s watcher chain. Having written my share of non-trivial directives, I can attest to the difficulty of using the directive system for extending core Angular.</p>
<p>Another problem is that the readability and maintainability of some directives tend to fall apart because they try to map procedural Javascript onto declarative HTML. This problem manifests itself in many ways: </p>
<ul>
<li><p><strong>awkward creep of Javascript logic into templates</strong></p>
<p>It&#39;s pretty common to run into scenarios like these:</p>
<pre><code class="lang-javascript">&lt;div ng-class=&quot;{&#39;text-success&#39;: item.value &gt; 50, &#39;text-danger&#39;: item.value &lt;= 50}&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Some stuff is just downright <a href="https://groups.google.com/d/msg/angular/7WY_BmFzd3U/Zd_jHnMu58YJ">clunky</a>:</p>
<pre><code class="lang-markup">&lt;input ng-model=&quot;search&quot; /&gt;
&lt;table&gt;
   &lt;tr ng-repeat-start=&quot;item in (filtered = items | filter: search)&quot;&gt;
       &lt;td colspan=&quot;2&quot;&gt;...&lt;/td&gt;
       &lt;td&gt;...&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr ng-repeat-end&gt;
       &lt;td&gt;...&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Showing {{filtered.length}} results&lt;/p&gt;
</code></pre>
<p>I&#39;ll leave it as an exercise to the reader to look up how to do recursive templates in Angular (e.g. for tree views) for another example.</p>
</li>
<li><p><strong>lack of proper error reporting</strong></p>
<p>Angular can do a pretty decent job with expression syntax errors, but because expressions are embedded in HTML, we don&#39;t get line numbers.</p>
<p>A perhaps more serious problem is the dubious feature that makes view expressions <a href="http://jsfiddle.net/pusf3/">swallow errors altogether</a>. Angular allows this because of its aggressive rendering profile:</p>
<pre><code class="lang-javascript">function SomeCtrl($scope, someAsyncService) {
   //Angular renders once here
   $scope.greeting = &quot;Hello&quot;

   someAsyncService(function(data) {
       //and another time here
       $scope.data = data
   })
}
</code></pre>
<pre><code class="lang-markup">&lt;div&gt;{{greeting}}&lt;/div&gt;

&lt;!--the null reference exception is swallowed here so the first render doesn&#39;t break--&gt;
&lt;div&gt;There are {{data.length}} things&lt;/div&gt;
</code></pre>
<p>Another semi-related problem: this is a common debugging technique in Angular:</p>
<pre><code class="lang-markup">&lt;div ng-repeat=&quot;item in items&quot;&gt;
   ...
&lt;/div&gt;

&lt;!--let&#39;s debug the `items` variable - this prints the JSON representation of the data--&gt;
{{items}}
</code></pre>
<p>It&#39;s surprisingly common to forget to remove a debug statement and the result can be far more embarrassing than it should be.</p>
</li>
<li><p><strong>leaky abstractions</strong></p>
<p>Consider this snippet:</p>
<pre><code class="lang-markup">&lt;div&gt;{{item}}&lt;/div&gt;
...
&lt;ul ng-repeat=&quot;item in items&quot;&gt;
   &lt;li&gt;{{item}}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>The variable <code>item</code> can mean different things in different places because of a programming language feature called <a href="http://en.wikipedia.org/wiki/Variable_shadowing">variable shadowing</a>.</p>
<p>But instead of using Javascript&#39;s built-in system, Angular builds its own implementation, with some weird results:</p>
<pre><code class="lang-markup">&lt;a href=&quot;&quot; ng-click=&quot;flag = true&quot;&gt;open&lt;/a&gt;

&lt;div ng-show=&quot;flag&quot;&gt;
   &lt;a href=&quot;&quot; ng-click=&quot;flag = false&quot;&gt;close&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p>Click on the <code>open</code> link, the <code>div</code> shows up. Click on <code>close</code>, it hides. Now let&#39;s say you want to use <code>ng-if</code> instead, maybe because you&#39;re finding yourself needing to use CSS nth-child selectors or as a performance optimization or whatever.</p>
<pre><code class="lang-markup">&lt;a href=&quot;&quot; ng-click=&quot;flag = true&quot;&gt;open&lt;/a&gt;

&lt;div ng-if=&quot;flag&quot;&gt;
   &lt;a href=&quot;&quot; ng-click=&quot;flag = false&quot;&gt;close&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p>Now this <a href="http://jsfiddle.net/54RXG/">doesn&#39;t work</a> as before. Considering that it is common to use the <code>ng-show</code>/<code>ng-if</code> feature when implementing lists or tables of big things with a fallback case for zero items, it&#39;s relatively easy to break completely unrelated parts of an app with a seemingly innocuous change.</p>
</li>
<li><p><strong>Performance</strong></p>
<p>Another problem related to Angular&#39;s re-implementation of scope (among other things) is the steep performance degradation when things like grids grow past a modest size. Often things look ok w/ test data, but with production-level data volume, you are sudddenly forced to discover about Angular internal concepts like watchers, dirty checking, apply cycles, etc, or you need to do massively time consuming audits of the codebase in order to figure out the feasibility of adding the ng-bindOnce plugin, or maybe you need to completely rewrite a top-level ng-repeat to use the ng-grid plugin instead.</p>
<p>It&#39;s extremely difficult to reason about Angular performance, and standard tools don&#39;t help very much.</p>
</li>
</ul>
<p>Mithril takes lessons from my Angular experience and it takes a completely different approach: <em>it maps HTML onto Javascript</em>. This means that instead of having to retrofit control flow into a declarative syntax that was never meant to support it, we simply take advantage of the standard DOM API that ships with all browsers to create and update the HTML from Javascript instead, and let Javascript do the job of the control flow, variable shadowing, recursiveness, etc. Use the right tool for the right job, etc.</p>
<p>In addition to resulting in a <em>really</em> small code footprint (~3kb gzipped), this approach allows a much higher level of expressiveness much more easily. In a <a href="http://lhorie.github.io/mithril-blog/building-a-seinfeld-app.html">previous post</a>, for instance, I showed a few examples of how simple it is to add application-focused expressiveness to a Mithril template.</p>
<pre><code class="lang-javascript">//a 7x7 grid of checkboxes where the cell for the current day is highlighted
var view = function(ctrl) {
    return m(&quot;table&quot;, seven(function(y) {
        return m(&quot;tr&quot;, seven(function(x) {
            var index = indexAt(x, y)
            return m(&quot;td&quot;, highlights(index), [
                m(&quot;input[type=checkbox]&quot;, checks(ctrl, index))
            ]);
        }));
    }));
};
</code></pre>
<p>The sample above illustrates that instead of having to use <code>repeat</code> and <code>model</code> directives and naked color hex values to make the computer do what we want, we can explicitly express that there are <code>seven</code> children in an element, that a cell <code>highlights</code> and that a checkbox <code>checks</code> - and we can implement these terms just as easily - they&#39;re just straightforward, transparent functions.</p>
<p>Because Mithril acknowledges that dynamic data binding in large systems is more procedural than declarative, we can leverage the full power of Javascript without getting tripped by <a href="http://en.wikipedia.org/wiki/Greenspun&#39;s_tenth_rule">Greenspun&#39;s tenth rule</a>, and without the need to learn framework-specific templating syntax that we&#39;ll probably not be using in 10 years.</p>
<p>But even though Mithril templates are ultimately plain Javascript, we don&#39;t necessarily need to sacrifice the familiar syntax of HTML in order to get the flexibility of Javascript: there&#39;s a nifty React-based transformer by Jonathan Buchanan <a href="https://groups.google.com/d/msg/mithriljs/lGiNpog2mbc/ThZSdgw_nucJ">that allows us to write templates with plain HTML syntax</a>.</p>
<p>We could also use Coffeescript instead, if that&#39;s your cup of, er, coffee.</p>
<p>The point is that in addition to having the refactoring power of a programming language available at no extra cost, we also get access to a wide array of tools: templates can be profiled granularly, minified, linted, unit tested <em>without the slowness of loading up PhantomJS</em>, etc. The &quot;Mithril ecosystem&quot; might still be in its infancy, but the Javascript ecosystem is huge and Mithril is ready to take advantage of it in ways that many frameworks can&#39;t even begin dreaming of.</p>
<p>Here&#39;s a cool example: we can use <a href="http://lhorie.github.io/mithril/compiling-templates.html">Sweet.js macros</a> to make existing code faster for free, or even <a href="https://github.com/mozilla/sweet.js/wiki/Example-macros">create new extensions to the language</a>, if we&#39;re bold enough. The elusive power of Lisp macros is now all of a sudden something that can actually be used in our frontend day-to-day work - without the need to <a href="http://artyom.me/learning-racket-1">learn a whole new language</a> or <a href="http://jlongster.com/Stop-Writing-JavaScript-Compilers--Make-Macros-Instead">learn about compilers</a>.</p>
<p>There are many other aspects of Mithril that are also worth mentioning. The rendering engine waits until controllers are fully done before redrawing instead of flickering incorrect states at every AJAX response. The routing system actually works with things like anchors (e.g. &quot;back to top&quot; links) and browser history lists (e.g. <code>Ctrl+H</code> in Chrome), instead of being, well, broken. The high performance is a result of a very aggressive take on the do-less-to-be-fast and the don&#39;t-reinvent-the-wheel mantras. The composability of the component system is rooted on the field of functional programming (rather than being an ad-hoc half-implementation) and thus it&#39;s mathematically sound.</p>
<p>All of these features have one thing in common: they originate from pain points from my experience with actually building non-trivial apps. Apps with fuzzy scope, top-down directed changes, ambiguous requirements, tight budgets and deadlines - you know, <em>real world</em> apps. At the end of the day, it&#39;s important for a framework to keep in mind that it doesn&#39;t exist for its own sake: rather than assuming an utopia where the developer has the luxury of deciding every aspect of an application&#39;s feature set, design and implementation, and where not-so-easy-to-implement things can be waved away with soft skills so that the developer can stay within the comfort zone of the framework, a framework must be prepared to take on the ugly reality of less than ideal workflows. </p>
<p>It&#39;s not supposed to be up to a framework to limit what I <a href="http://stackoverflow.com/questions/9682092/databinding-in-angularjs">can and cannot do</a>, and it&#39;s not supposed to be <a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md">breaking</a> high impact aspects of application space every other release.</p>
<p>These are things that you only really &quot;get&quot; if you&#39;re burned by them, and burned by them I have been. These lessons were part of every design decision and every line of code in Mithril, and are always part of the ongoing progress of the project: stability before new features, research before code (even for small-looking changes), regression tests, &quot;it-is-not-done-until-it-is-documented&quot; (and yes, things <em>do</em> get done), etc.</p>
<p>Anyways, I was only planning on talking about templating engines, but I guess things dragged on a bit. The point though is that Mithril scratches <em>a lot</em> of itches, not just in terms of just templating, or even just code: it does so for frontend application development as a whole.</p>

			]]></description>
		</item>
		<item>
			<title>Curry flavored promises</title>
			<link>http://lhorie.github.io/mithril-blog/curry-flavored-promises.html</link>
			<description><![CDATA[
<h2 id="curry-flavored-promises">Curry flavored promises</h2>
<p><em>April 27, 2014</em></p>
<p>One aspect of <a href="http://lhorie.github.io/mithril">Mithril</a> that is pretty nice is that it allows us to use <a href="http://lhorie.github.io/mithril/mithril.deferred.html">promises</a>.</p>
<p>Promises are basically a mechanism that lets you chain a bunch of functions, which then get called asynchronously later when, say, an AJAX request completes:</p>
<pre><code class="lang-javascript">//a little helper function
var now = Date.now()
var pastItems = function(items) {
    return items.filter(function(item) {
        return item.date &lt; now
    });
};

//here&#39;s an AJAX request and a chain of promises
m.request({method: &quot;GET&quot;, url: &quot;/api/projects&quot;})
    .then(console.log) // log all projects
    .then(pastItems) // filter past projects
    .then(console.log) // log past projects only
</code></pre>
<p>Notice we&#39;re not calling <code>console.log()</code> nor <code>pastItems()</code>, but instead we&#39;re passing them to the promise&#39;s <code>.then()</code> method. What the code above does should be self-explanatory: it requests some projects, then logs them, then filters the list to only contain past projects, then logs the past projects. The one caveat that should be mentioned is that the only thing that happens immediately is the AJAX call. All the functions we passed to <code>.then</code> methods are only called at a later time, when the request completes.</p>
<p>Organizing our code as shown above is useful because it makes it easier for us to reuse code:</p>
<pre><code class="lang-javascript">m.request({method: &quot;GET&quot;, url: &quot;/api/vacations&quot;})
    .then(pastItems) // filter past vacations
    .then(console.log) // log past vacations
</code></pre>
<p>We can use the <code>pastItems</code> function to filter the result of a <code>vacations</code> web service (or any other web services) in addition to the projects one. Of course, we can also call the function directly if we have a list laying around that we want to filter.</p>
<p>We can mix and match code too:</p>
<pre><code class="lang-javascript">//another helper function
var createdByJohnDoe = function(items) {
    return items.filter(function(item) {
        return item.createdBy == &quot;John Doe&quot;
    });
};

m.request({method: &quot;GET&quot;, url: &quot;/api/projects&quot;})
    .then(pastItems) // filter past projects
    .then(createdByJohnDoe) // filter projects created by john doe
    .then(console.log) // log past projects created by john doe
</code></pre>
<p>A clever reader will probably notice that even though the code above is terse and modular, there is some room for improvement: The <code>createdByJohnDoe</code> function is not very reusable - we want to be able to filter by an arbitrary user, not just John Doe.</p>
<p>Fortunately, refactoring is easy. We can simply refactor our function to accept a <code>user</code> argument:</p>
<pre><code class="lang-javascript">var createdBy = function(user, items) {
    return items.filter(function(item) {
        return item.createdBy == user
    });
};
</code></pre>
<p>And then, we can <strong>curry</strong> this generic <code>createdBy</code> function to get the equivalent of <code>createdByJohnDoe</code> again:</p>
<pre><code class="lang-javascript">m.request({method: &quot;GET&quot;, url: &quot;/api/projects&quot;})
    .then(pastItems) // filter past projects
    .then(createdBy.bind(this, &quot;John Doe&quot;)) // filter projects created by john doe
    .then(console.log) // log past projects created by john doe
</code></pre>
<p>And voila! Curry flavored promises.</p>
<hr>
<h3 id="what-voodoo-magic-is-this-">What voodoo magic is this?</h3>
<p>Let&#39;s slow down a bit.</p>
<p>As we saw from the function definition earlier, <code>createdBy</code> can be called like this:</p>
<pre><code class="lang-javascript">var things = [
    {name: &quot;foo&quot;, createdBy: &quot;John Doe&quot;},
    {name: &quot;bar&quot;, createdBy: &quot;Jane Doe&quot;},
    {name: &quot;baz&quot;, createdBy: &quot;Mary Doe&quot;},
];
var byJohn = createdBy(&quot;John Doe&quot;, things); // [{name: &quot;foo&quot;, createdBy: &quot;John Doe&quot;}]
</code></pre>
<p>Currying is a functional programming technique that lets us pre-define arguments in a function. So <code>createdBy.bind(this, &quot;John Doe&quot;)</code> returns a function whose <code>user</code> argument is already set to &quot;John Doe&quot;. The <code>this</code> argument is, as you might have guessed, what the <code>this</code> should point to inside of the curried function. Since we don&#39;t actually use <code>this</code> in <code>createdBy</code>, this value doesn&#39;t actually matter for our purposes.</p>
<p>One subtle thing to notice is that the curried function can still take more arguments, which will be mapped to whatever is the first argument that is not yet bound via the curry. Therefore, the curried function can be called like this:</p>
<pre><code class="lang-javascript">var createdByJohnDoe = createdBy.bind(this, &quot;John Doe&quot;);

var byJohn = createdByJohnDoe(things); //[{name: &quot;foo&quot;, createdBy: &quot;John Doe&quot;}]
</code></pre>
<p>Whereas the signature of <code>createdBy</code> is <code>function(user, items)</code>, in the curried <code>createdByJohnDoe</code> function, the signature is simply <code>function(items)</code> because <code>user</code> is already present via an internal closure. Since <code>items</code> is the first argument of <code>createdByJohnDoe</code>, we can then pass this function to the promise&#39;s <code>.then()</code> method, which takes a function with signature <code>function(value)</code>, whose argument <code>value</code> is bound to the value being piped through the promise chain.</p>
<p>So in the same way that calling <code>.then(console.log)</code> is equivalent to the code below:</p>
<pre><code>.then(function(value) {
    console.log(value)
})
</code></pre><p>the same is true about the curried <code>createdByJohnDoe</code>. We can simply use the one-liner <code>.then()</code> calls as shown earlier, without the need to create the anonymous function.</p>
<p>Currying is a powerful technique that allows us to generalize and modularize our code, and then bring the pieces back together in a modular way.</p>
<p>This is one of the ways to avoid callback hell (i.e. zig-zaggy-indentation code made up of deeply nested callbacks), while at the same time enumerating the types of operations present in your app in a way that is easy to find, read and organize.</p>
<hr>
<h3 id="parting-thoughts">Parting thoughts</h3>
<p>I&#39;ll end this post with one last nugget: did you wonder why we are filtering projects on the client side? Usually it would make more sense to do so in the server (and more accurately, in the database server), but this is not always necessarily the case. Let&#39;s say that you do happen to have a full list of projects somewhere else in your app because it&#39;s something that the app deals with a lot. It&#39;s perfectly reasonable that your client-side model layer could cache that list, and that instead of re-fetching the data from the server, you could just tap into the client-side cache.</p>
<p>Since we are building an extensive arsenal of modular filter functions, we can just fetch the list once (maybe even put it in localStorage), and then slice and dice the cached list in a variety of ways without the need for a bunch of similar but just slightly different web service requests, and without the need to write a single extra line of SQL to support those slightly different requests.</p>
<p>So, you see, instead of spending all our time writing old style callback-driven code with lots of anonymous functions and a ton of custom SQL and other boilerplate code to support it, we can actually start spending time thinking of more efficient ways to deal with the data in our app in a much more comprehensive way. We can even start dreaming about things like offline apps.</p>
<p>Food for thought? Bon appetit!</p>

			]]></description>
		</item>
		<item>
			<title>Better templates with FP</title>
			<link>http://lhorie.github.io/mithril-blog/better-templates-with-fp.html</link>
			<description><![CDATA[
<h2 id="better-templates-w-fp">Better Templates w/ FP</h2>
<p><em>April 20, 2014</em></p>
<p>Every once in a while, when I start writing a new application, I create a page layout with a header and some navigation, and then some time later I need to have more than one page. Then I realize that the layout is hard coded and parts of it needs to be refactored out of my original page in order to avoid the need to copy and paste the global elements in every page. Sounds familiar?</p>
<p><a href="http://lhorie.github.io/mithril">Mithril</a> lets us take advantage of functional programming to create decoupled, composable templates - in other words, templates that you can mix and match.</p>
<p>For example, let&#39;s suppose we are building a site that has a menu and a body area:</p>
<pre><code class="lang-javascript">var layout = function() {
    return m(&quot;.layout&quot;, [
        m(&quot;header&quot;, [
            &quot;nav here&quot;
        ]),
        m(&quot;main&quot;, [
            &quot;body here&quot;
        ])
    ]);
};

m.module(document, {controller: function() {}, view: layout});
</code></pre>
<p>In case that code is not clear enough, here&#39;s what the output HTML looks like:</p>
<pre><code class="lang-markup">&lt;div class=&quot;layout&quot;&gt;
    &lt;header&gt;
        nav here
    &lt;/header&gt;
    &lt;main&gt;
        body here
    &lt;/main&gt;
&lt;/div&gt;
</code></pre>
<p>What we want to do is be able to dynamically define what <code>nav here</code> and <code>body here</code> are. In other words, we want a layout that looks like this:</p>
<pre><code class="lang-javascript">var layout = function(nav, body) {
    return m(&quot;.layout&quot;, [
        m(&quot;header&quot;, nav),
        m(&quot;main&quot;, body)
    ]);
};
</code></pre>
<p>And sub-templates that look like this:</p>
<pre><code class="lang-javascript">var nav = function() {
    return [
        &quot;nav here&quot;
    ];
};
var body = function() {
    return [
        &quot;body here&quot;
    ];
};
</code></pre>
<p>By organizing our code like this, the sub-templates don&#39;t need to be cluttered with explicit layout references, and the layout can flexibly render different navs and bodies as our app grows in complexity. In other words, organizing our code this way gives us nice and modular templates.</p>
<p>So all we need now is a glue to put together these nice modular pieces of code together.</p>
<p>Since functions are first class citizens in Javascript, we can create a <strong>higher order function</strong> - a function that works with functions - to do that for us:</p>
<pre><code class="lang-javascript">var mixinLayout = function(layout, nav, body) {
    return function() {
        return layout(nav(), body());
    };
};
</code></pre>
<p>All this function does is take templates as arguments (remember, Mithril templates are just functions), and then return a function that calls them (side note: the returned function is also a template).</p>
<p>And that&#39;s it! Now we can create as many layouts, navs and bodies as we want and we can put them together however we want to create our views:</p>
<pre><code class="lang-javascript">//here&#39;s a module
var myModule = {};
myModule.controller = function() { /*...*/ };
myModule.view = mixinLayout(layout, nav, body);

//here&#39;s another module
var anotherModule = {};
anotherModule.controller = function() { /*...*/ };
anotherModule.view = mixinLayout(layout, anotherNav, anotherBody);

//hook up our modules to routes
m.route(document, &quot;/foo&quot;, {
    &quot;/foo&quot;: myModule,
    &quot;/bar&quot;: anotherModule
});
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced usage</h3>
<p>This technique becomes very powerful when using <a href="http://lhorie.github.io/mithril/components.html">components</a> to organize code. For example, you might have a widget that lives in its own page (e.g. a login widget), but this widget may also appear in a modal dialog somewhere else in the site.</p>
<p>By writing the login widget&#39;s template as a self-contained function as we saw above, we can attach a layout for the standalone login page, and we can just include the naked template as a component in our modal dialog. No copy-pasta required.</p>
<pre><code class="lang-javascript">//the widget template
var loginWidget = function() {
    return [
        m(&quot;input[placeholder=&#39;Username&#39;]&quot;),
        m(&quot;input[placeholder=&#39;Password&#39;][type=&#39;password&#39;]&quot;),
        m(&quot;button&quot;)
    ]
}

//standalone page
var loginPage = {}
loginPage.controller = function() { /*...*/ }
loginWidget.view = mixinLayout(layout, nav, loginWidget)

//as a component in another part of the app
var anotherPlace = {}
anotherPlace.controller = function() { /*...*/ }
anotherPlace.view = function() {
    return [
        &quot;stuff before&quot;,
        loginWidget(),
        &quot;stuff after&quot;
    ]
}
</code></pre>
<p>It&#39;s worth noting that even though I call this an example of &quot;advanced usage&quot; and throw around fancy words like &quot;components&quot;, the code itself is actually surprisingly straightforward.</p>
<p>Hopefully this article sheds some light into ways to keep templates DRY, and how Mithril&#39;s simplicity can help achieve that goal.</p>

			]]></description>
		</item>
		<item>
			<title>Building a "Seinfeld" App</title>
			<link>http://lhorie.github.io/mithril-blog/building-a-seinfeld-app.html</link>
			<description><![CDATA[
<h2 id="building-a-seinfeld-app">Building a &quot;Seinfeld&quot; App</h2>
<p><em>April 13, 2014</em></p>
<p>To-do apps have become the &quot;hello world&quot; of javascript frameworks; they are easy to build and just structured enough to be a good showcase of framework features.</p>
<p>Today we&#39;re going to take that one step further and use <a href="http://lhorie.github.io/mithril">Mithril</a> to build something that is a little bit more focused and a little bit more useful.</p>
<p>You may have heard of the <a href="http://lifehacker.com/281626/jerry-seinfelds-productivity-secret">&quot;don&#39;t break the chain&quot; concept, made famous by comedian Jerry Seinfeld</a>. The gist is this: if there&#39;s an activity you want to turn into a habit, get a calendar and put an &quot;X&quot; on every day that you do it. The goal is to have a lot of consecutive &quot;X&quot;s, with no gaps, hence &quot;don&#39;t break the chain&quot;.</p>
<p>The rationale behind this is that a lot of people have trouble sticking with something for long periods of time due to lack of focus or prioritization tools or whatever. Seinfeld&#39;s trick just makes use of gamification to nudge us to be more persistent than we perhaps would be without the aid of a tool. So that&#39;s what we&#39;re gonna build.</p>
<hr>
<h3 id="view-layer">View layer</h3>
<p>Let&#39;s start by creating an HTML file:</p>
<pre><code class="lang-markup">&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Don&#39;t break the chain&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;mithril.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
        //app goes here
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>There&#39;s really no consensus on the number of days needed to actually form a habit, so let&#39;s just build a 7x7 grid because 7 days per week is familiar and squares are pretty.</p>
<p>Here&#39;s what we might want our grid template to look like:</p>
<pre><code class="lang-javascript">//our app&#39;s namespace
var chain = {};

//model goes here

//controller goes here

//view
chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function() {
        return m(&quot;tr&quot;, chain.seven(function() {
            return m(&quot;td&quot;, [
                m(&quot;input[type=checkbox]&quot;)
            ]);
        });
    });
};
</code></pre>
<p>If you were coding along, you would probably notice that typing 7 table rows and 7 columns per row would result in a pretty big and repetitive template. So what we did above is define a <strong>stub</strong> method called <code>chain.seven</code> which will repeat whatever you pass to it 7 times. </p>
<p>Stubbing basically means just calling a function that doesn&#39;t exist yet. It&#39;s a great way of cranking out some code quickly: it helps mitigate &quot;analysis paralysis&quot; by letting you focus on the easy stuff (i.e. the general DOM structure), so you can worry about the repetition stuff in isolation later.</p>
<p>Note that implementing <code>chain.seven</code> is an easy-to-complete task, so it makes for a good warm-up task to get the juices going if you were to stop working on this app now and came back to work on it tomorrow. This is a powerful productivity trick: if you&#39;re getting bogged down, just write a stub and move on! It helps you shift away from the all-or-nothing approach to development that stalls a lot of people and nudges you towards incremental progress. </p>
<p>Now that we have do have our basic grid structure figured out, we can get the <code>chain.seven</code> utility out of the way:</p>
<pre><code class="lang-javascript">//create a helper utility that we can use in the view
chain.seven = function(subject) {
    var output = [];
    for (var i = 0; i &lt; 7; i++) output.push(subject(i));
    return output;
};
</code></pre>
<p>Note that we pass the iteration index <code>i</code> as a parameter to the <code>subject</code> callback. This will be useful later.</p>
<p>It&#39;s worth noting that KISS (&quot;keep it simple, stupid&quot;) is a strong driving principle in Mithril. Note how we didn&#39;t need to look up any framework APIs to create the <code>chain.seven</code> extension to our view language. It&#39;s just plain javascript. We can quickly make our templates as expressive and application-specific as we want.</p>
<p>Combined w/ techniques like stubbing, you can write code almost as fast as it appears in your mind, and rely on your console&#39;s null reference exceptions as a running &quot;todo list&quot; of sorts.</p>
<p>Now that we have a basic template setup, we can render it to see what it looks like:</p>
<pre><code class="lang-javascript">//our app&#39;s namespace
var chain = {};

chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function() {
        return m(&quot;tr&quot;, chain.seven(function() {
            return m(&quot;td&quot;, [
                m(&quot;input[type=checkbox]&quot;)
            ]);
        }));
    }));
};

//create a helper utility that we can use in the view
chain.seven = function(subject) {
    var output = [];
    for (var i = 0; i &lt; 7; i++) output.push(subject(i));
    return output;
};

//render it
m.module(document.body, {controller: function() {}, view: chain.view});
</code></pre>
<hr>
<h3 id="model-layer">Model layer</h3>
<p>Now we can start thinking about functionality. Our app is pretty simple: all we need to do is make checkboxes retain their states after they&#39;ve been checked.</p>
<p>Since it&#39;s highly unlikely that anyone is ever going to keep the app running for days on end, we need a persistence layer. The simplest thing we can use is <code>LocalStorage</code>. It doesn&#39;t work in older browsers, but we don&#39;t want to get bogged down setting up a database for a tutorial app that we&#39;re probably only going to use in our own smartphones, so it&#39;s adequate enough.</p>
<p>The LocalStorage API is pretty straightforward. If you add a property to the <code>localStorage</code> object, its value is cast to a string:</p>
<pre><code class="lang-javascript">localStorage.test = 1 // &quot;1&quot;
localStorage.foo = [1, 2, 3] // &quot;1,2,3&quot;
localStorage.bar = {a: 1} // &quot;[object Object]&quot;
</code></pre>
<p>Our app consists of 49 days, which can be either marked with an &quot;X&quot;, or not. So what we need to do is persist a list of booleans. Since LocalStorage has no concept of fetching a subset of a data list, the simplest storage implementation would be something like this:</p>
<pre><code>//a list model API
chain.save = function(list) {
    localStorage[&quot;chain-app.list&quot;] = JSON.stringify(list);
};
chain.load = function() {
    return JSON.parse(localStorage[&quot;chain-app.list&quot;] || &quot;[]&quot;);
};
</code></pre><p>This API can be used like this:</p>
<pre><code class="lang-javascript">var list = chain.load();
list[42] = true; //set the 42nd day
chain.save(list);

//reset the list
chain.save([]);
</code></pre>
<p>In addition to the actual list of checks, we also need to know when our chain started. So we also need an auxiliary model entity to store the start date.</p>
<pre><code class="lang-javascript">//a date model API
chain.today = function() {
    var now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
}
chain.resetDate = function() {
    return localStorage[&quot;chain-app.start-date&quot;] = chain.today().getTime();
}
chain.startDate = function() {
    return new Date(parseInt(localStorage[&quot;chain-app.start-date&quot;] || chain.resetDate()));
}
chain.dateAt = function(index) {
    var date = new Date(chain.startDate());
    date.setDate(date.getDate() + index);
    return date;
}
</code></pre>
<p>This API can be used like this:</p>
<pre><code class="lang-javascript">var today = chain.today() //today at midnight

var startDate = chain.startDate(); //start date is today

var isToday = chain.dateAt(3).getTime() === chain.today() //is three days from now the same as today? Should be false

//reset
var newStartDate = chain.resetDate(); //new start date is today
</code></pre>
<p>Again, note how we didn&#39;t need to use any framework code in the model layer. We could have used classes, but we&#39;re just creating an API without them to illustrate the point that it&#39;s perfectly possible to maintain the MVC pattern while prototyping, without the need for bureaucracy. As long as our APIs are simple and well defined, we can always refactor later.</p>
<hr>
<h3 id="controller-layer">Controller layer</h3>
<p>In Mithril, controllers are typically meant to be the glue between the model and view layer. Here&#39;s one way to implement it:</p>
<pre><code class="lang-javascript">chain.controller = function() {
    var list = chain.load();

    this.isChecked = function(index) {
        return list[index]
    };
    this.check = function(index, status) {
        if (chain.dateAt(index).getTime() &lt;= chain.today().getTime()) {
            list[index] = status;
            chain.save(list);
        }
    };
};
</code></pre>
<p>Our controller doesn&#39;t actually expose the raw list from the model. Instead it implements a <code>isChecked</code> method to read the state for a given day, and a <code>check</code> method to set it (with some validation to prevent setting days in the future).</p>
<p>With this API, we are able to expose all the model data that we need to the view. Below is an example of how this controller API can be used:</p>
<pre><code class="lang-javascript">var ctrl = new chain.controller();

var isFirstDayChecked = ctrl.isChecked(0); //is first day checked?

ctrl.check(0, true); //check off the first day
</code></pre>
<p>Now that we have a controller attached to our namespace, we can actually use it as a Mithril module, i.e. we can just pass the namespace object wholesale to Mithril initializer method:</p>
<pre><code class="lang-javascript">//call this at the end of the code to initialize the `chain` app
m.module(document.body, chain);
</code></pre>
<p>With this call, the controller gets instantiated and this instance is passed to the view as a parameter (the <code>ctrl</code> argument of the <code>view</code> function).</p>
<hr>
<h3 id="putting-it-all-together">Putting it all together</h3>
<p>Now all we need to do is make the view layer dynamically load the data that we exposed via the controller. Normally, this is done in frameworks via what are called <strong>bi-directional data bindings</strong>.</p>
<p>A bi-directional data binding is really just a fancy way of saying that a DOM element has code attached to it that sets its value based on our model data, and an event handler to update the model data when a UI change happens.</p>
<p>Here&#39;s a simple binding helper function: it returns the set of attributes needed to do bi-directional data binding based on a controller instance and an model layer&#39;s list index.</p>
<pre><code class="lang-javascript">chain.checks = function(ctrl, index) {
    return {
        onclick: function() {
            ctrl.check(index, this.checked);
        },
        checked: ctrl.isChecked(index)
    };
}
</code></pre>
<p>Now we can use this binding in the template we created at the beginning:</p>
<pre><code class="lang-javascript">chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function(y) {
        return m(&quot;tr&quot;, chain.seven(function(x) {
            return m(&quot;td&quot;, [
                m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, chain.indexAt(x, y)))
            ]);
        }));
    }));
};
</code></pre>
<p>If you have been paying attention you probably noticed that we just defined another stub called <code>chain.indexAt</code>: our template doesn&#39;t expose the raw offset that we need for our model API, but the <code>chain.seven</code>&#39;s callback argument can be used to compute it.</p>
<p><code>chain.indexAt(x, y)</code> will need to take a grid position and return the appropriate flat-list index, assuming that the days are counted like in a regular calendar.</p>
<pre><code class="lang-javascript">chain.indexAt = function(x, y) {
    return y * 7 + x;
}
</code></pre>
<p>This should be enough to make the UI dynamic: you should be able to check off a box, refresh the page and see that it retained its state.</p>
<p>Before we continue, let me just me a note about data bindings. Most frameworks have generic binding syntax, but they&#39;re often prescriptive and inflexible.</p>
<p>Creating our own custom bindings like we did above has a lot of advantages: we can have super expressive code that reads almost like prose - <code>m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, chain.indexAt(x, y)))</code> is roughly &quot;a checkbox that checks the index that corresponds to these x and y coordinates&quot;</p>
<p>In addition, we can maintain full control over the implementation, and we can keep these implementation details neatly tucked in the view layer, rather than pollute the controller layer or having to create other complexity layers.</p>
<hr>
<p>One last thing we can do to make the app more usable is highlight the checkbox that corresponds to the current day. Let&#39;s write another data binding for this:</p>
<pre><code class="lang-javascript">chain.highlights = function(index) {
    return {
        style: {
            background: chain.dateAt(index).getTime() == chain.today().getTime() ? &quot;silver&quot; : &quot;&quot;
        }
    };
};
</code></pre>
<p>Notice that this binding is not bi-directional - it doesn&#39;t need an event handler. All it does is set a background color based on whether the cell corresponds to today.</p>
<p>We can then refactor our view to use our new binding:</p>
<pre><code class="lang-javascript">chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function(y) {
        return m(&quot;tr&quot;, chain.seven(function(x) {
            var index = chain.indexAt(x, y)
            return m(&quot;td&quot;, chain.highlights(index), [
                m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, index))
            ]);
        }));
    }));
};
</code></pre>
<p>This last binding is noteworthy for a few reasons: for one thing, it illustrates how we can easily tuck away noisy template snippets - I mean, really, who likes inline style attributes? :)</p>
<p>Another thing to notice is that despite this snippet being part of the view layer (conceptually), it accesses the model directly (it calls <code>chain.today</code>) without going through the controller. Logically, the concept of &quot;today&quot; doesn&#39;t need class instantiation management, so it&#39;s perfectly reasonable to skip controller bureaucracy for it altogether.</p>
<p>The last thing to note is that because our views are plain javascript, things like caching computed values (<code>var index</code> in our case) are easy to do and completely transparent, so it&#39;s highly unlikely that you would ever run into <a href="http://stackoverflow.com/questions/14376879/error-10-digest-iterations-reached-aborting-with-dynamic-sortby-predicate">bizarre problems</a>.</p>
<hr>
<h3 id="conclusion">Conclusion</h3>
<p>This is pretty much all we need to have a working app. Here&#39;s the code in its entirety:</p>
<pre><code class="lang-javascript">&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Don&#39;t break the chain&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;mithril.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
//our app&#39;s namespace
var chain = {};

//model
chain.save = function(list) {
    localStorage[&quot;chain-app.list&quot;] = JSON.stringify(list);
};
chain.load = function() {
    return JSON.parse(localStorage[&quot;chain-app.list&quot;] || &quot;[]&quot;);
};

chain.today = function() {
    var now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
}
chain.resetDate = function() {
    return localStorage[&quot;chain-app.start-date&quot;] = chain.today().getTime();
}
chain.startDate = function() {
    return new Date(parseInt(localStorage[&quot;chain-app.start-date&quot;] || chain.resetDate()));
}
chain.dateAt = function(index) {
    var date = new Date(chain.startDate());
    date.setDate(date.getDate() + index);
    return date;
}



//controller
chain.controller = function() {
    var list = chain.load();

    this.isChecked = function(index) {
        return list[index]
    };
    this.check = function(index, status) {
        if (chain.dateAt(index).getTime() &lt;= chain.today().getTime()) {
            list[index] = status;
            chain.save(list);
        }
    };
};



//view
chain.view = function(ctrl) {
    return m(&quot;table&quot;, chain.seven(function(y) {
        return m(&quot;tr&quot;, chain.seven(function(x) {
            var index = chain.indexAt(x, y)
            return m(&quot;td&quot;, chain.highlights(index), [
                m(&quot;input[type=checkbox]&quot;, chain.checks(ctrl, index))
            ]);
        }));
    }));
};

chain.seven = function(subject) {
    var output = [];
    for (var i = 0; i &lt; 7; i++) output.push(subject(i));
    return output;
};

chain.checks = function(ctrl, index) {
    return {
        onclick: function() {
            ctrl.check(index, this.checked);
        },
        checked: ctrl.isChecked(index)
    };
};

chain.highlights = function(index) {
    return {
        style: {
            background: chain.dateAt(index).getTime() == chain.today().getTime() ? &quot;silver&quot; : &quot;&quot;
        }
    };
};

chain.indexAt = function(x, y) {
    return y * 7 + x;
}

//render it
m.module(document.body, chain);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>From here, you can start adding polish to the app: <a href="http://stackoverflow.com/questions/8195741/how-do-they-do-this-mobile-site-added-to-homescreen-appears-as-standalone-app">making it &quot;Add to Home Screen&quot; friendly</a>, maybe <a href="http://webdesign.tutsplus.com/tutorials/quick-tip-easy-css3-checkboxes-and-radio-buttons--webdesign-8953">styling the checkboxes</a>, or just using a CSS framework like <a href="http://getbootstrap.com/">Bootstrap</a> for a quick improvement in look and feel, etc.</p>
<hr>
<h3 id="homework">Homework</h3>
<p>You probably noticed that this app doesn&#39;t let you write down what is the actual activity that you are tracking. Adding a text input that lets you do so and saves this text to <code>localStorage</code> is a good homework assignment to solidify all the important concepts we covered in the article.</p>
<p>Another feature that you should try to add is a button to reset the app (after all, an app that becomes useless after 49 days is no fun.)</p>
<p>If you want to build more experience with real life coding, another thing you can do is take this app and improve it so that you can track more than one activity. This is a great exercise for reading existing code and refactoring, as well as learning more about useful <a href="http://lhorie.github.io/mithril">Mithril</a> features.</p>
<p>Remember that if you need help or have questions, you are always welcome to post in the <a href="https://groups.google.com/forum/#!forum/mithriljs">mailing list</a> or send me an <a href="https://github.com/lhorie/">email</a>.</p>

			]]></description>
		</item>
		<item>
			<title>Giving Mithril a voice</title>
			<link>http://lhorie.github.io/mithril-blog/giving-mithril-a-voice.html</link>
			<description><![CDATA[
<h2 id="giving-mithril-a-voice">Giving Mithril a voice</h2>
<p><em>April 11, 2014</em></p>
<p>I released Mithril last month and the project has been getting generally positive feedback and some <a href="https://github.com/jpmonette/todomvc-mithril">good</a> <a href="https://github.com/insin/msx">traction</a>.</p>
<p>There&#39;s still a lot of things I want to share with people that aren&#39;t necessarily core Mithril features, be them interesting application developement techniques, or my own experience w/ development and even open source in general, so today I&#39;m launching this blog.</p>
<p>To give a recap of what&#39;s been happening since launch, Mithril is now a lot more accessible, being <a href="http://lhorie.github.io/mithril/installation.html">available from CDNs, and popular NodeJS package managers</a>.</p>
<p>In addition to this blog, the <a href="https://groups.google.com/forum/#!forum/mithriljs">mailing list</a> and the <a href="https://github.com/lhorie/mithril.js/issues?state=open">Github issue tracker</a> are great places to start conversations.</p>
<p>On the plumbing end, Mithril is now on Travis CI, and the test suite is rapidly growing. It now includes regression tests for reported bugs to ensure a stable core.</p>
<p>For the next little while, I&#39;m hoping to nail down all the lingering bugs that contributors have been finding (particularly around the <code>m.render</code> method). Once I feel it&#39;s stable enough to bump Mithril to a v0.2, I&#39;ll have the chance to start putting more time on the plugin ecosystem, which has a really exciting pipeline: more readable and expressive templates, advanced optimization tools, a more wholesome approach to dependency management, etc - and hopefully no changes to the core codebase in order to support all of this :)</p>
<p>If you&#39;re liking Mithril, you can help in a few different ways. The easiest is to spread the word. Another way is to try it out and report any bugs you find. You&#39;re also welcome to post topics in the mailing list or get in touch with me directly.</p>
<p>If you want a project to take on, there&#39;s a lot of stuff that can be done in terms of plugins, and if you need help getting started, I&#39;m more than happy to help get the ball moving for you. <a href="https://github.com/lhorie/mithril.js/issues/38">This thread</a>, for example is a good starting point.</p>
<p>In the coming weeks, I&#39;m hoping to start writing more topics about actual development, both in general, and as it relates to Mithril, so stay tuned :)</p>

			]]></description>
		</item>
	</channel>
</rss>